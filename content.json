{"meta":{"title":"wang-zhibiao'blog","subtitle":"I am is a boy","description":"note","author":"wangzhibiao","url":"http://wang-zhibiao.github.io"},"pages":[{"title":"about","date":"2019-06-16T13:48:33.000Z","updated":"2019-06-16T13:48:34.047Z","comments":true,"path":"about/index.html","permalink":"http://wang-zhibiao.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"vue数据劫持","slug":"vue数据劫持","date":"2020-03-27T02:51:56.000Z","updated":"2020-03-27T08:16:22.934Z","comments":true,"path":"2020/03/27/vue数据劫持/","link":"","permalink":"http://wang-zhibiao.github.io/2020/03/27/vue数据劫持/","excerpt":"","text":"MVC思想web开发中，我们会使用原生的html去实现简单的静态官网，但是在遇到交互极多极复杂的情况下，就力有不逮。 MVC由三大部分组成： view 视图层 model 数据管理层 controller 响应用户的操作，并且更新model到view上 在MVC的情况下我们如果好进行更新model呢 用户点击某个搜索按钮 发送ajax请求 更新model view视图层更新数据 123456789101112131415161718192021222324$('#button').click(function()&#123; $.ajax(&#123; url:'3.query.php',//地址 dataType:'json',//数据类型 type:'GET',//类型 timeout:2000,//超时 //请求成功 success:function(data,status)&#123; //更新model let element = document.getElementById(\"button\") //操作DOM元素进行替换数据 &#125;, //失败/超时 error:function(XMLHttpRequest,textStatus,errorThrown)&#123; if(textStatus==='timeout')&#123; alert('請求超時'); setTimeout(function()&#123; alert('重新请求'); &#125;,2000); &#125; //alert(errorThrown); &#125; &#125;) &#125;) MVVM思想MVVM 由 Model,View,ViewModel 三部分构成。Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 12345678910111213141516171819202122232425262728293031323334353637let obj = &#123;&#125;;let song = '发如雪'; obj.singer = '周杰伦'; Object.defineProperty(obj, 'music', &#123; // 1. value: '七里香', configurable: true, // 2. 可以配置对象，删除属性 // writable: true, // 3. 可以修改对象 enumerable: true, // 4. 可以枚举 // ☆ get,set设置时不能设置writable和value，它们代替了二者且是互斥的 get() &#123; // 5. 获取obj.music的时候就会调用get方法 return song; &#125;, set(val) &#123; // 6. 将修改的值重新赋给song song = val; &#125;&#125;);// 下面打印的部分分别是对应代码写入顺序执行console.log(obj); // &#123;singer: '周杰伦', music: '七里香'&#125; // 1delete obj.music; // 如果想对obj里的属性进行删除，configurable要设为true 2console.log(obj); // 此时为 &#123;singer: '周杰伦'&#125;obj.music = '听妈妈的话'; // 如果想对obj的属性进行修改，writable要设为true 3console.log(obj); // &#123;singer: '周杰伦', music: \"听妈妈的话\"&#125;for (let key in obj) &#123; // 默认情况下通过defineProperty定义的属性是不能被枚举(遍历)的 // 需要设置enumerable为true才可以 // 不然你是拿不到music这个属性的，你只能拿到singer console.log(key); // singer, music 4&#125;console.log(obj.music); // '发如雪' 5obj.music = '夜曲'; // 调用set设置新的值console.log(obj.music); // '夜曲' 6 来源：掘金","categories":[{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"},{"name":"数据劫持","slug":"数据劫持","permalink":"http://wang-zhibiao.github.io/tags/数据劫持/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/categories/vue/"}]},{"title":"js技术","slug":"js技术","date":"2020-03-19T06:14:14.000Z","updated":"2020-05-26T10:07:01.007Z","comments":true,"path":"2020/03/19/js技术/","link":"","permalink":"http://wang-zhibiao.github.io/2020/03/19/js技术/","excerpt":"","text":"Vue中对于style属性和class属性的使用12345678910111213141516171819202122232425262728//正常&lt;div style=\"width:100px\"&gt; style&lt;/div&gt;//骚操作//对象写法&lt;div :style=\"&#123;width:'200px','text-align':center,color: activeColor, fontSize: fontSize + 'px',color:(index==0?arr.conFontColor:'#000')&#125;\"&gt;&lt;/div&gt;&lt;div :class=\"&#123; active: isActive, 'text-danger': hasError, active: this.isActive &amp;&amp; !this.error,'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125;\"&gt;&lt;/div&gt;//切换样式写法&lt;div :class=\"isActive == true ? 'isFixed' :''\"&gt;&lt;/div&gt;&lt;div :class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt;&lt;div :class=\"[&#123; active: isActive &#125;, errorClass]\"&gt;&lt;/div&gt;//数组语法&lt;div :style=\"[&#123;width:'100px','text-align':center, fontSize: 100 + 'px',color:(index==0?arr.conFontColor:'#000')&#125;,&#123;width:'200px','text-align':center,color: activeColor, fontSize: fontSize + 'px',color:(index==0?arr.conFontColor:'#000')&#125;]\"&gt; style&lt;/div&gt;//一个属性多个值时&lt;div :style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt;&lt;/div&gt;data: &#123; activeColor: 'red', fontSize: 30&#125;data: &#123; isActive: true, hasError: false&#125; vue中对watch的利用1234567891011121314151617181920212223watch: &#123; \"planForm.number\": function(newVal, oldVal) &#123; // 解决数字键盘可以输入输入多个小数点问题 if (newVal == \"\" &amp;&amp; oldVal.toString().indexOf(\".\") &gt; 0) &#123; this.planForm.number = oldVal; return; &#125; // 保留两位小数 if (newVal) &#123; newVal = newVal.toString(); var pointIndex = newVal.indexOf(\".\"); //不出现两位小数点 if (newVal.toString().lastIndexOf(\".\") &gt; pointIndex) &#123; this.planForm.number = oldVal; return; &#125; if (pointIndex &gt; 0 &amp;&amp; newVal.length - pointIndex &gt; 3) &#123; this.planForm.number = oldVal; return; &#125; &#125; &#125;&#125;, 一个map函数内使用里面对某个子项进行every判断是否为数字123value.mpa(v=&gt;&#123; if(v.every(item=&gt;isNaN(item)))&#123;&#125;&#125;) 什么是 IIFE (立即调用的函数表达式)IIFE是一个立即调用的函数表达式，它在创建后立即执行 1234(function IIFE()&#123; console.log( \"Hello!\" );&#125;)();// \"Hello!\" 无loop生成指定长度的数组12const List = len =&gt;[...new Array(len).keys()]const list = List(10) //=&gt;list=[0,1,2,3,4,5,6,7,8,9] 数组的去重12const list = [1,2,45,1,5,4,245,2];const uniqueList = [ ...new Set(list)] //=&gt;uniqueList= [1,2,45,5,4,245] 点击回到顶部的js12345678910111213141516171819202122232425262728293031323334Gotop.onclick = function () &#123; //判断是否有无定时器 if (c) &#123; clearInterval(c); &#125; c = setInterval(function () &#123; var target = 0; //顶部的距离 var step = 10; //每次滚动的距离 var curent = getScroll().scrollTop; //滚动出去的距离 //判定有没有滚动 if (curent &gt; target) &#123; step = -Math.abs(step); &#125; //使页面开始一直往上滚 curent += step; document.documentElement.scrollTop = curent; document.body.scrollTop = curent; //判断最后页面是不是到了最开始的位置 if (Math.abs(curent) &lt;= target) &#123; clearInterval(c); document.documentElement.scrollTop = target; document.body.scrollTop = target; return; &#125; &#125;, 2) &#125; // 获取页面滚动出去的距离，处理兼容性 function getScroll() &#123; return &#123; scrollTop: document.documentElement.scrollTop || document.body.scrollTop, scrpllLeft: document.documentElement.scrpllLeft || document.body.scrollLeft &#125; &#125; map返回就是一个新的数组，也就是说 可以使用new进行创建一个数组 for in 使用12345let object = &#123;a:1,b:2,c:3&#125;for(let i=0 in object)&#123; console.log(i)&#125;// a,b,c for...in 语句以原始插入顺序迭代对象的可枚举属性。 for...of 语句遍历可迭代对象定义要迭代的数据。 for in 去掉对象中为空的键值12345for (const key in filter) &#123; if (filter[key] === \"\") &#123; delete filter[key]; &#125; &#125; 数组对象的去重1234567let TempObj = &#123;&#125;;let newArr = [...arr1,...arr2].reduce( (item, next) =&gt; &#123; TempObj[next.id]? \"\": (TempObj[next.id] = true &amp;&amp; item.push(next)); return item; &#125;,[]); 说明：其中item代表的是数组的每次遍历之后的项，next表示遍历的下一项。 生成随机字符串 (可指定长度)12345678910111213141516/** * 生成随机字符串(可指定长度) * @param len * @returns &#123;string&#125; */randomString = function(len) &#123; len = len || 8; var $chars = &apos;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&apos;; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = &apos;&apos;; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125; 生成随机颜色值123456789function getRandomColor () &#123; const rgb = [] for (let i = 0 ; i &lt; 3; ++i)&#123; let color = Math.floor(Math.random() * 256).toString(16) color = color.length == 1 ? &apos;0&apos; + color : color rgb.push(color) &#125; return &apos;#&apos; + rgb.join(&apos;&apos;)&#125; 对象的键值不仅仅只是一个字符串1234567891011let user = &#123; name:'wang', age:20&#125;let key = 'name';user[key] //=&gt; 输出wang//key 可以是一个变量let key = prompt(\"What do you want to know about the user?\", \"name\");//prompt 浏览器的输入弹窗 在输入后会返回输入的值给key（默认输入name）user[key] //==&gt; John（如果输入 \"name\"） 我们对于变量的键值应该是灵活的使用 key是一个变量可以通过变量的赋值进而改变对象的输出 对象内的计算属性我们可以在对象字面量中使用方括号。这叫做 计算属性。 1234567let key = prompt(\"What do you want to know about the user?\", \"name\");let user = &#123; [key]: \"wang\", // 属性名是从 key 变量中得到的&#125;;alert( user.name ); // 5 如果 key=\"name\" 对象的属性判断是否存在 12user.key === undefined 返回true表示不存在“key” in user 返回true表示存在 city.json城市JSON数据处理为级联组件适用的结构12345678910111213Object.keys(City).forEach(city =&gt; &#123; if (City[city].level === 1) &#123; let tempArr = []; City[city].children.map(v =&gt; &#123; tempArr.push(&#123; id: City[v].id, name: City[v].name &#125;); &#125;); tempCity.push(&#123; id: City[city].id, name: City[city].name, children: tempArr &#125;); &#125; &#125;); 计算指定数字的阶乘利用递归调用来进行数字的阶乘 12345678910111213const factorialOfNumber = number =&gt; number &lt; 0 ? (() =&gt; &#123; throw new TypeError(&apos;请输入正整数&apos;) &#125;)() : number &lt;= 1 ? 1 : number * factorialOfNumber(number - 1) // 事例factorialOfNumber(4) // 24factorialOfNumber(8) // 40320 字符串反转12const reverseString = string =&gt; [...string].reverse().join('')reverseString(121245) //=&gt; 542121 数字数组的排序123456//从大到小const sortArr = (array, number = 1) =&gt; [...array].sort((x, y) =&gt; y -x)//sortArr([0,5,7,87,2]) ==&gt;[87, 7, 5, 2, 0]//从小到大const sortArr = (array, number = 1) =&gt; [...array].sort((x, y) =&gt; x-y)//sortArr([0,5,7,87,2]) ==&gt;[0, 2, 5, 7, 87] 检查数组对象中的所有对象的isChecked键值为true1const isChecked = array =&gt; array.every(el =&gt; el.isChecked) 检查数组对象中的所有元素是否有一个isChecked键值为true1const isChecked = array =&gt; array.some(el =&gt; el.isChecked) 测试js代码的执行耗时:performance：1234567let start = performance.now(); let sum = 0; for (let i = 0; i &lt; 100000; i++) &#123; sum += 1; &#125; let end = performance.now(); console.log(start);console.log(end); 避免多条件并列开发中有时会遇到多个条件，执行相同的语句，也就是多个||这种： 1234567891011if(status==1||status==2||status==3)&#123; doSomeThing()&#125;switch(status)&#123; case 1： case:2 case:3: doSomeThing()&#125; 12345const enum = [1,2,3]if (enum.includes(status)) &#123; doSomething()&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"vue-elementUI使用笔记","slug":"vue-elementui使用笔记","date":"2020-03-17T16:00:00.000Z","updated":"2020-03-19T07:50:20.706Z","comments":true,"path":"2020/03/18/vue-elementui使用笔记/","link":"","permalink":"http://wang-zhibiao.github.io/2020/03/18/vue-elementui使用笔记/","excerpt":"","text":"vue-elementUI使用笔记elementUI的具名插槽1234 &lt;el-input placeholder=\"请输入\" v-model.number=\"data.number\" class=\"input-with-select\"&gt; &lt;el-button slot=\"prepend\" class=\"budget\" icon=\"el-icon-search\"&gt;搜索&lt;/el-button&gt; &lt;el-button slot=\"append\" class=\"budget\" icon=\"el-icon-search\"&gt;搜索&lt;/el-button&gt;&lt;/el-input&gt; slot=”preprend” 在输入框前面插入按钮(可以对应jQuery中的逻辑的prepend() 方法在被选元素的开头（仍位于内部）插入指定内容） slot=”append” 在输入框后面面插入按钮(可以对应jQuery中的逻辑的append() 方法在被选元素的结尾（仍然在内部）插入指定内容） 1234567&lt;el-form-item&gt; &lt;span slot=\"label\" class=\"tabs\"&gt; &lt;i class=\"el-icon-date\"&gt;&lt;/i&gt; 表单项名 &lt;/span&gt; &lt;el-input v-model=\"vlue\"&gt;&lt;/el-input&gt;&lt;/el-form-item&gt; 123456&lt;el-tab-pane name=\"keywords\"&gt; &lt;span slot=\"label\" class=\"tabs\"&gt; &lt;i class=\"el-icon-date\"&gt;&lt;/i&gt; 关键词 &lt;/span&gt;&lt;/el-tab-pane&gt; 对于一些弹出框 气泡 tooltip 都需要一个参考(reference)的标签进行提示 实际作用是作为弹出框的position的绝对定位的相对定位(根据此标签进行绝对定位) 123456789&lt;el-popover placement=\"top\" title=\"标题 width=\"200\" trigger=\"hover\" content=\"展示内容&gt; &lt;i class=\"iconfont icon-wenhao\" slot=\"reference\"&gt;&lt;/i&gt;&lt;/el-popover&gt; table表格渲染问题table表格是根据数据源进行渲染,当你需要在请求后再次渲染数据 只需要注意对于数据源的深拷贝就可以让table组件进行再次渲染数据 123456 &lt;CustomTable :dataSources=&quot;tableData&quot; :totalNumber=&quot;totalNumber&quot; @loadData=&quot;handelGetList&quot; v-loading=&quot;loading&quot;/&gt; 当第一次请求已经得到数据 tableData时,再次发送请求 1234567891011let data = await getData(params)//已经赋值数据，table已渲染this.tableData = data.list;//暂存一下数据let tempArr = data.list;getOtherData(params).then(res=&gt;&#123; tempArr = &#123; ...res, ...tempArr &#125;; //深拷贝的方法，但是只适合数据结构嵌套不深的数据，slice和JSON都可以对数据进行深拷贝 // this.tableData = JSON.parse(JSON.stringify(tempArr)); // this.tableData = tempArr.slice(0, tempArr.length);&#125;) select选择器v-model取值为当前对象当选择的数据需要options选中的label对应的对象数据时，使用value-key 12345678910111213141516171819202122 &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择广告主&quot; value-key=&quot;id&quot; &gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.id&quot; :label=&quot;item.name&quot; :value=&quot;item&quot; &gt;&lt;/el-option&gt; &lt;/el-select&gt;//在data中定义options属性，当组件有多个选择器 可以将数据源options抽离//使用as可自定义属性名 //import * as Options from &quot;@/assets/OPTIONS/options.js&quot;;import &#123;Options&#125; from &quot;@/assets/OPTIONS/options.js&quot;;data()&#123;return &#123; Options &#125;&#125; 当使用select组件的远程搜索且多选时，组件的再次搜索会令前面的组件显示为value实际id 使用reduce保存旧值1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;el-select v-model=\"data\" multiple filterable clearable remote reserve-keyword value-key=\"id\" placeholder=\"请输入搜索词\" :remote-method=\"remoteMethod\"&gt; &lt;el-option v-for=\"item in options\" :key=\"item.id\" :label=\"item.name\" :value=\"item\" &gt; &lt;span style=\"float:left\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/el-option&gt;&lt;/el-select&gt; methods: &#123; async remoteMethod(query) &#123; if (query !== \"\") &#123; let params = &#123; name: query &#125;; let query = await QueryData(params).then(res =&gt; &#123; return res; &#125;); var TempObj = &#123;&#125;; this.options = [...query, ...this.data].reduce( (item, next) =&gt; &#123; TempObj[next.id] ? \"\" : (TempObj[next.id] = true &amp;&amp; item.push(next)); return item; &#125;, [] ); &#125; else &#123; this.options = []; &#125; &#125;, &#125; form表单表单验证规则12345678910111213141516171819202122&lt;el-form :model=&quot;Form&quot; :rules=&quot;rules&quot; ref=&quot;Form&quot; label-width=&quot;150px&quot; v-loading=&quot;loading&quot;&gt; &lt;el-form-item label=&quot;显示名&quot; prop=&quot;data.key&quot; class=&quot;custom&quot;&gt; &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择广告主&quot; value-key=&quot;id&quot; &gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.id&quot; :label=&quot;item.name&quot; :value=&quot;item&quot; &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt;&lt;/el-form&gt; rules.js 1234567891011121314export const rules = &#123; //当from中的数据level为一层 Form：&#123;one：\"1\"&#125; one：: [&#123; required: true, message: '请选择', trigger: 'change' &#125;] //当数据为多层时。 Form:&#123;first:&#123;secend:'1'&#125;&#125; 需要在el-form-item标签中定义 prop=\"first.secend\" \"first.secend\": [&#123; required: true, message: '请选择', trigger: 'change' &#125;]&#125; 123如何解决rule验证规则在提示后切换影响其他验证规则(实际是验证规则会在el-form-item标签下生成一个div 提示el-form-item__error 但是在渲染时候v-if判断某个条件时无法再次重渲染)在el-form-item上加入 :key=&quot;ruleskeys&quot; data定义为 ruleskeys：1 其他受影响的加上 :key=&quot;ruleskeys+1&quot;在保证key值不一致的情况下 当v-if判断后会重新渲染 dialog对话框对话框显示隐藏1234567891011&lt;Dialog :visible=\"ShowdialogVisible\" @hideDialog=\"ShowdialogVisible = false\"/&gt;//组件内 &lt;el-dialog title=\"标题\" :visible.sync=\"showDialog\" width=\"500px\" @closed=\"$emit('hideDialog')\"&gt;&lt;/el-dialog&gt; props: &#123; visible: Boolean, &#125;, data() &#123; return &#123; showDialog: false &#125;; &#125;,","categories":[{"name":"elementUI使用笔记","slug":"elementUI使用笔记","permalink":"http://wang-zhibiao.github.io/categories/elementUI使用笔记/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"},{"name":"elementUI","slug":"elementUI","permalink":"http://wang-zhibiao.github.io/tags/elementUI/"}],"keywords":[{"name":"elementUI使用笔记","slug":"elementUI使用笔记","permalink":"http://wang-zhibiao.github.io/categories/elementUI使用笔记/"}]},{"title":"JavaScript的变量以及数据类型","slug":"变量和js类型的理解","date":"2020-01-09T01:24:56.000Z","updated":"2020-03-19T08:58:53.826Z","comments":true,"path":"2020/01/09/变量和js类型的理解/","link":"","permalink":"http://wang-zhibiao.github.io/2020/01/09/变量和js类型的理解/","excerpt":"","text":"一、JavaScript数据类型ECMAScript标准规定了7种数据类型，其把这7种数据类型又分为两种：原始类型和对象类型。 原始类型 Null：只包含一个值：null Undefined：只包含一个值：undefined Boolean：包含两个值：true和false Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN） String：一串表示文本值的字符序列 Symbol：一种实例是唯一且不可改变的数据类型 (在es10中加入了第七种原始类型BigInt，现已被最新Chrome支持) 对象类型 Object：自己分一类丝毫不过分，除了常用的Object，Array、Function等都属于特殊的对象 区分原始类型和对象类型 - 不可变性 原始类型存放在栈空间中，而复杂类型存放在堆空间中 栈内存： 存储的值大小固定 空间较小 可以直接操作其保存的变量，运行效率高 由系统自动分配存储空间 堆内存： 存储的值大小不定，可动态调整 空间较大，运行效率低 无法直接操作其内部存储，使用引用地址读取 通过代码进行分配空间 字符串 具备不可变性不管是字符串的裁切splice 还是 toLowerCase 都是在原有的基础上产生新的字符串 JavaScript中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。 由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的 对象 具备可变性引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。 数组 是一个复杂（引用）类型 通过一些api可以改变数组 pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素 push()向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度 shift()把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值 unshift()向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度 reverse()颠倒数组中元素的顺序，改变原数组，返回该数组 sort()对数组元素进行排序，改变原数组，返回该数组 splice()从数组中添加/删除项目，改变原数组，返回被删除的元素 当我们进行复制时两者有着本质的区别 这里涉及到浅拷贝和深拷贝—本质是复制时是否改变复制的对象的数值或属性或方法 原始类型12345var name = 'wang';var newName = name;newName = 'Mr.wang';console.log(name) // =&gt;wangconsole.log(newName) // =&gt;Mr.wang 内存中有一个变量name，值为wang。我们从变量name复制出一个变量newName，此时在内存中创建了一个块新的空间用于存储wang，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。 引用类型12345var obj = &#123;name:'wang'&#125;;var newObj = obj;newObj.name = 'Mr.wang';console.log(obj.name) //=&gt; Mr.wangconsole.log(newObj.name)//=&gt; Mr.wang 当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的newObj实际上和obj指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。 原始类型和引用类型的比较原始类型，比较时会直接比较它们的值，如果值相等，即返回true。 引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为false。 区分null和undefinednull 表示被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值。 所以对象的某个属性值为null是正常的，null转换为数值时值为0。 undefined 表示“缺少值”，即此处应有一个值，但还没有定义， 如果一个对象的某个属性值为undefined，这是不正常的，如obj.name=undefined，我们不应该这样写，应该直接delete obj.name。 undefined转为数值时为NaN(非数字值的特殊值) JavaScript是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是undefined的意义所在。对于JAVA这种强类型语言，如果有&quot;undefined&quot;这种情况，就会直接编译失败，所以在它不需要一个这样的类型。 你想不到的0.1+0.2≠0.3 本质是：由于数字在js中的计算是先转换为二进制在进行计算的，然后以十进制输出 12345678910111213141516171819202122232425262728function judgeFloat(n, m) &#123; const binaryN = n.toString(2); const binaryM = m.toString(2); console.log(`$&#123;n&#125;的二进制是 $&#123;binaryN&#125;`); console.log(`$&#123;m&#125;的二进制是 $&#123;binaryM&#125;`); const MN = m + n; const accuracyMN = (m * 100 + n * 100) / 100; const binaryMN = MN.toString(2); const accuracyBinaryMN = accuracyMN.toString(2); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制是$&#123;binaryMN&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是 $&#123;accuracyBinaryMN&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制再转成十进制是$&#123;to10(binaryMN)&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是再转成十进制是$&#123;to10(accuracyBinaryMN)&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;在js中计算是$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? '' : '不'&#125;准确的`); &#125; function to10(n) &#123; const pre = (n.split('.')[0] - 0).toString(2); const arr = n.split('.')[1].split(''); let i = 0; let result = 0; while (i &lt; arr.length) &#123; result += arr[i] * Math.pow(2, -(i + 1)); i++; &#125; return result; &#125; judgeFloat(0.1, 0.2); judgeFloat(0.6, 0.7); 计算机中所有的数据都是以二进制存储的，所以在计算时计算机要把数据先转换成二进制进行计算，然后在把计算结果转换成十进制。 由上面的代码不难看出，在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。 隐式转换 if语句和逻辑语句在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true： 123456nullundefined&apos;&apos;NaN0false 各种运数学算符我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型; 12341 - true // 01 - null // 11 * undefined // NaN2 * [&apos;5&apos;] // 10 注意+是个例外，执行+操作符时： 1.当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。 2.当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。 3.当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。 1234123 + &apos;123&apos; // 123123 （规则1）123 + null // 123 （规则2）123 + true // 124 （规则2）123 + &#123;&#125; // 123[object Object] （规则3） == 运算符使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）： 1.NaN NaN和其他任何类型比较永远返回false(包括和他自己)。 1NaN == NaN // false 2.Boolean Boolean和其他任何类型比较，Boolean首先被转换为Number类型。 1234true == 1 // true true == &apos;2&apos; // falsetrue == [&apos;1&apos;] // truetrue == [&apos;2&apos;] // false 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0： 12undefined == false // falsenull == false // false 3.String和Number String和Number比较，先将String转换为Number类型。 12123 == &apos;123&apos; // true&apos;&apos; == 0 // true 4.null和undefined null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。 1234567null == undefined // truenull == &apos;&apos; // falsenull == 0 // falsenull == false // falseundefined == &apos;&apos; // falseundefined == 0 // falseundefined == false // false 5.原始类型和引用类型 当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型: 12&apos;[object Object]&apos; == &#123;&#125; // true&apos;1,2,3&apos; == [1, 2, 3] // true 来看看下面这个比较： 1[] == ![] // true !的优先级高于==，![]首先会被转换为false，然后根据上面第三点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。 12[null] == false // true[undefined] == false // true 根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。 原型链的规则 1.所有引用类型都具有对象特性，即可以自由扩展属性 2.所有引用类型都具有一个proto（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型proto值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的proto中去找 toString上面我们在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。 每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中type是对象的类型。 0.11加上0.1不等于0.1解决方法 1parseFloat((prev + curr).toFixed(2)) JavaScript怎么把两个数组里的多个对象一一对应合并？123456789101112131415161718192021222324252627var obj1 = [&#123; \"id\": 980550455852, \"model\": \"XQG70-S1208FW\", \"color\": \"白\", \"invStatusName\": \"正品\", \"bactualQty\": 10947, \"brealyQty\": 11000, \"bavailQty\": 53&#125;, &#123; \"id\": 980550566221, \"model\": \"XQB70-C3006\", \"color\": \"灰\", \"invStatusName\": \"正品\", \"bactualQty\": 11, \"brealyQty\": 6, \"bavailQty\": -5&#125;];var obj2 = [&#123; \"price\": \"6666\"&#125;, &#123; \"price\": \"8888\"&#125;];var obj = obj1.map((item,index) =&gt; &#123; return &#123;...item, ...obj2[index]&#125;;&#125;);console.log(obj); //","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"csss实用技巧持续更新","slug":"实用css技巧","date":"2019-12-31T16:10:56.000Z","updated":"2020-03-19T08:59:17.796Z","comments":true,"path":"2020/01/01/实用css技巧/","link":"","permalink":"http://wang-zhibiao.github.io/2020/01/01/实用css技巧/","excerpt":"","text":"lessless中的变量12345678910111213/*如何定义@变量名=变量值如何使用在样式中属性:变量名例子定义*/@color=#f00；/*使用*/a&#123;color:color;background:color;&#125; less的循环 ，使用递归123456789101112.box1&#123; border-bottom:10px solid #ccc;&#125;.box2&#123; border-bottom:20px solid #ccc;&#125;.box3&#123; border-bottom:30px solid #ccc;&#125;.box4&#123; border-bottom:40px solid #ccc;&#125; 1234567.loop(@cout)when(@cout&gt;0)&#123; .loop((@cout-1)) .box@&#123;cout&#125;&#123; border-bottom:@cout+0px solid #ccc; &#125;&#125;.loop(3) 原生css的声明变量1234567891011121314151617/*声明变量 使用 -- 关键字调用变量 使用 var() 函数*/a&#123; --color: red; /* 使用变量 必须放在var函数内 */ background-color: var(--color);&#125;var(--变量名,参数) div &#123; height: 500px; /* 默认参数 200px */ padding-top: var(--padding-top,200px); /* 默认参数 10px solid red */ border: var(--border, 10px solid red); /* 默认参数 linear-gradient(yellow,red) */ background-image: var(--img,linear-gradient(yellow,red)); &#125; css的计算（calc）123div&#123; height:calc(100px*90)&#125; 将超出的文本以…的方式缩减123456789.line2 &#123; display: -webkit-box; overflow: hidden; white-space: normal!important; text-overflow: ellipsis; word-wrap: break-word; -webkit-line-clamp: 2; -webkit-box-orient: vertical&#125; flex弹性布局子元素居中12345div&#123; display:flex; justify-content:center; align-content:center;&#125; 使用:not()选择器123ul&gt;li:not(last-child)&#123; border-right: 1px solid #666;&#125; not()是可以令最后一项li不加右边框，表示否定 使用伪类+content+position+transform实现文字或者图形的样式 1234567891011121314/*文字实现 ° 度数单位*/ div &#123; width: 150px; height: 30px; border: 1px solid #000; position: relative; &#125;div::after &#123; content: '°'; position: absolute; top: 0; right: 10px; &#125; bing.com搜索的国际版按钮的布局1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt;span &#123; width: 82px; height: 36px; display: block; position: relative; margin-right: 8px; cursor: pointer;&#125;span i &#123; position: absolute; z-index: 2; display: block; width: 100%; height: 100%; line-height: 30px; text-align: center; color: #fff;&#125;span::after &#123; position: absolute; left: 0; top: 0; display: block; content: \"\"; width: 100%; height: 100%; border: 1px rgba(255, 255, 255, 0.2) solid; border-bottom: none; transform: scale(1.1, 1.3) perspective(0.7em) rotateX(2.2deg); /*重点*/ transform-origin: bottom left; background: rgba(0, 0, 0, 0.5); border-radius: 1px 2px 0 0; box-sizing: border-box;&#125;&lt;/style&gt;&lt;body&gt; &lt;span&gt; &lt;i&gt;国际版&lt;/i&gt; &lt;/span&gt;&lt;/body&gt; 清除浮动123456789101112131415161718192021222324.clearfix&#123; zoom: 1; /*IE6*/&#125;.clearfix:after&#123; content: \".\"; height: 0; clear: both; display: block; visibility: hidden;&#125;// 全浏览器通用的clearfix方案【推荐】// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.clearfix:before,.clearfix:after &#123; display: table; content: \" \";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 使用overflow-x排版横向列表1overflow-x:auto 说明：通过flexbox或inline-block的形式横向排列子元素，对父元素设置overflow-x:auto横向滚动查看，或者设置overflow-x:auto 纵向滚动条一般用于商品分类 使用letter-spacing排版倒序文本1letter-spacing:-10px 说明：通过letter-spacing设置负值字体间距将文本倒序 使用::selection改变文本选择颜色123.demo::selection&#123; background-color: green;&#125; 说明：可以让你选择的文字设置单独的css样式 css禁用鼠标事件12345.disabled &#123; pointer-events: none; cursor: default; opacity: 0.6;&#125; 数组去重12345678910111213141516171819202122// indexOf实现var array = [1, 1, '1'];function unique(array) &#123; var res = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i]; if (res.indexOf(current) === -1) &#123; res.push(current) &#125; &#125; return res;&#125;// filter实现var array = [1, 2, 1, 1, '1'];function unique(array) &#123; var res = array.filter(function(item, index, array)&#123; return array.indexOf(item) === index; &#125;) return res;&#125;console.log(unique(array)); 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?1234567function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d&#123;3&#125;)+\\.)/g, function($1, $2)&#123; return $2 + &apos;,&apos;; &#125;); &#125; 目前Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出： 121a = 7.5px1rem = 75p 所有的下载插件都可以在文件-&gt;首选项-&gt;设置进行修改 某些插件需要重启才能进行使用 css字体不让选中 class样式添加以下： 12345678910div&#123;-webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none;&#125; css之滚动条当设置这两个属性时，只允许Y轴滚动（纵向） 12overflow: scroll;overflow-x: hidden; sroll-snap-type这个属性规定了一个容器是否对内部滚动动作进行捕捉，并且规定了如何去处理滚动结束状态。 mandatory：强制性强制使滚动条停止在scroll-snap-align:设定的位置 12345&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 1234567ul &#123; scroll-snap-type: x mandatory;&#125;li &#123; scroll-snap-align: center;&#125; scroll-snap-type: x mandatory;对于X轴的捕捉控制，scroll-snap-align: center;强制使li回到中间 proximity 接近、临近、大约滚动结束后可能还在原来的地方，也可能额外滚动 scroll-snap-margin/scroll-snap-padding可以设定margin padding 进行控制，滚动条的盒子属性 scroll-snap-type: both mandatory对于X和Y轴同时可进行滚动 scroll-snap-align: start | center | end;子元素相对于父元素的对其方式","categories":[{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/tags/css/"},{"name":"实用","slug":"实用","permalink":"http://wang-zhibiao.github.io/tags/实用/"}],"keywords":[{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/categories/css/"}]},{"title":"vue-cli3.0的开发","slug":"vue3.0开发过程","date":"2019-12-12T04:12:12.000Z","updated":"2020-03-19T08:58:20.166Z","comments":true,"path":"2019/12/12/vue3.0开发过程/","link":"","permalink":"http://wang-zhibiao.github.io/2019/12/12/vue3.0开发过程/","excerpt":"","text":"项目结构 解析：项目存在public（公共） favicon.ico（网站图标） index.html(入口文件) 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt; &lt;title&gt;网站名&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We're sorry but advertisement doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.runtime.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js\"&gt;&lt;/script&gt; &lt;script src=\"http://jira.finway.com.cn/vue-source/axios.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此入口采用cdn引入外部的element-ui axios vue vue-router moment srcsrc作为项目的资源文件存放路径-包含以下的子文件夹 assets存放images，JSON文件 调用时可以使用 路径 “@/assets/images/“+”图片名” components（自定义公共组件）如果你创建了一些公共组件 在整个项目中多次调用时，可以拆分为单独的公共组件 request（请求）/api对于axios的二次封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// 引入模块import axios from \"axios\"import router from '../router'import &#123;Message&#125; from 'element-ui'// 是否允许跨域axios.defaults.withCredentials = true;// axios初始化：延迟时间，主路由地址let instance = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, timeout: 10000,&#125;);// 设置拦截器instance.interceptors.request.use( config =&gt; &#123; config.headers = &#123; 'Content-Type':'application/x-www-form-urlencoded' &#125; //在发送请求之前做某事 return config; &#125;, error =&gt; &#123; //请求错误时做些事 Promise.reject(error) &#125;);//响应拦截器instance.interceptors.response.use( response =&gt; &#123; //请求结束成功 if (response.status === 200 || response.status === 304 || response.status === 201) &#123; return response.data.data &#125; return response; &#125;, error =&gt; &#123; //请求错误时做些事 if (error &amp;&amp; error.response) &#123; if (error.response.status === 400 || String(error).indexOf('code 400') !== -1) &#123; Message.error(error.response.data.message) return Promise.reject(error.response.data) &#125; if (error.response.status === 401 || String(error).indexOf('code 401') !== -1) &#123; Message.error(error.response.data.message) // 函数进入then后面的第二个err函数，如果没有就进入catch函数, 表单提交就可以根据这个重置参数以及重置按钮状态，防止按钮卡滞 // return Promise.reject(error) &#125; if (String(error).indexOf('code 500') !== -1) &#123; if (error.response.data.message) &#123; Message.error(error.response.data.message) &#125; else &#123; Message.error('服务器出现问题，请刷新重试') &#125; return Promise.reject(error) &#125; // 终止Promise调用链 return error // return new Promise(() =&gt; &#123;&#125;) &#125; &#125;);// 是否销毁拦截器// 1.给拦截器起个名称 var myInterceptors = instance.interceptors.requesst.use();// 2.instance.interceptors.request.eject(myInterceptor);//模块化导出export default &#123; get(url, params = &#123;&#125;) &#123; if (!url) return; return instance(&#123; method: 'get', url: url, params, timeout: 30000 &#125;) &#125;, post(url, data = &#123;&#125;) &#123; if (!url) return; return instance(&#123; method: 'post', url: url, data, timeout: 3000000 &#125;) &#125;, postFile(url, data) &#123; if (!url) return; return instance(&#123; method: 'post', url: url, data &#125;) &#125;, put(url, data) &#123; if (!url) return; return instance(&#123; method: 'put', url: url, data &#125;) &#125;, patch(url, data) &#123; if (!url) return; return instance(&#123; method: 'patch', url: url, data &#125;) &#125;, delete(url, data) &#123; if (!url) return; return instance(&#123; method: 'delete', url: url, data, timeout: 30000 &#125;) &#125;,&#125; 在自定义的分类api中把请求路径进行分类 12345678910111213import axios from \"../axios\";function login(params) &#123; return axios.post(\"/api/login\", params);&#125;function logout() &#123; return axios.get(\"/api/logout\");&#125;export &#123; login, logout&#125;; storestore-modules定义 wang.js 1234567891011121314151617181920212223242526272829303132import &#123;getRegionData,&#125; from \"@/request/api/addPlan\";const state = &#123; City: [],&#125;;const getters = &#123;&#125;;const mutations = &#123; setCity(state, payload) &#123; state.City = payload; &#125;,&#125;;const actions = &#123; async getCIty(&#123; commit &#125;, payload) &#123; const res = await getRegionData(&#123; access_token: payload.access_token &#125;); commit(\"setCity\", res.data); &#125;,&#125;;export default &#123; namespaced: true, state, getters, actions, mutations&#125;; 注意必须在store-index.js(入口)引入 1234567891011import Vue from 'vue'import Vuex from 'vuex'import wang from './modules/wang'Vue.use(Vuex)export default new Vuex.Store(&#123; modules: &#123; wang, &#125;, getters&#125;) 对于getters的使用定义getters.js 1234const getters = &#123; City: state =&gt; state.wang.City,&#125;export default getters 在页面.vue使用 123456789101112import &#123; mapGetters &#125; from \"vuex\";export default &#123;computed: &#123; ...mapGetters([\"City\"]) &#125;, methods:&#123; wang()&#123; console.log(this.City) &#125; &#125;&#125; styles(css样式)分成element.css(修改UI的样式),index.css（主要的样式）,reset.css（样式初始化） index.js 123@import './reset.css';@import './icon.css';@import './element.css'; 在main.js引入 12//初始化css样式import '@/styles/index.css' utils(工具)每个项目特有的工具函数，封装了对应项目需要的公共函数 views(视图)包含Home.vue (主体视图窗口) 布局容器的使用及插槽 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div class=\"home\"&gt; &lt;!-- 主体框架 --&gt; &lt;el-container&gt; &lt;el-aside :style=\"isCollapse ? &#123;width:0+'px'&#125; : &#123;width:200+'px'&#125;\"&gt; &lt;Aside /&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;Header /&gt; &lt;/el-header&gt; &lt;!-- router-view插槽 --&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import &#123; mapGetters &#125; from \"vuex\";import Header from \"../components/header\";import Aside from \"../components/aside\";export default &#123; computed: &#123; ...mapGetters([\"isCollapse\"]) &#125;, name: \"home\", data() &#123; return &#123; width: 200 &#125;; &#125;, components: &#123; Header, Aside &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"less\" scoped&gt;.home &#123; min-width: 1263px; height: 100%;&#125;&lt;/style&gt; 在views定义的模板.vue都需要在路由进行引入 App.vue只有一个路由插槽 12345678&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; main.js(主要文件)main用于外部资源的引入以及vue的全局绑定 123456789101112131415161718192021import Vue from 'vue'import App from './App.vue'import router from './router'import axios from './request/axios'import store from './store/index'import ElementUI from 'element-ui' //element-ui的全部组件import 'element-ui/lib/theme-chalk/index.css' //element-ui的cssVue.use(ElementUI, &#123; size: 'small', zIndex: 3000&#125;)//全局绑定axiosVue.prototype.$http = axios;//初始化css样式import '@/styles/index.css'Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app') router.js(路由)1234567891011121314151617181920212223242526import Vue from 'vue'import Router from 'vue-router'import Home from './views/Home.vue'Vue.use(Router)//解决导航栏重复点击跳转报错报错const originalPush = Router.prototype.pushRouter.prototype.push = function push(location) &#123; return originalPush.call(this, location).catch(err =&gt; err)&#125;export default new Router(&#123; routes: [&#123; path: '/', name: 'home', component: Home, redirect: '/popularize', children: [&#123; path: '/popularize', name: 'popularize', component: resolve =&gt; require(['@/views/popularize/popularize.vue'], resolve) &#125; ] &#125;, ]&#125;) 在最新的vue-router中已经解决这个问题 可删除 12345//解决导航栏重复点击跳转报错报错const originalPush = Router.prototype.pushRouter.prototype.push = function push(location) &#123; return originalPush.call(this, location).catch(err =&gt; err)&#125; 路由的懒加载方式 12component: resolve =&gt; require(['@/views/popularize/popularize.vue'], resolve)component: () =&gt; import('@/views/popularize/popularize.vue') .env.development（开发模式的环境变量）在开发中有一些需要单独抽离的变量 api请求的baseUrl(注意命名必须前缀带VUE_APP__) 1VUE_APP_BASE_API ='http://dev.dsp.api.kuafugame.com' 在axios.js中使用 1process.env.VUE_APP_BASE_API .env.production(上线后的环境变量，为打包所使用).gitignore(npm忽略清单) 123456789101112131415161718192021.DS_Storenode_modules/dist# local env files.env.local.env.*.local# Log filesnpm-debug.log*yarn-debug.log*yarn-error.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln*.sw? 在项目准备上线后，请配置好vue.config.js 脚手架配置最基本的配置1234567891011121314151617181920212223242526module.exports = &#123; publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"/\", // outputDir: 在npm run build时 生成文件的目录 type:string, default:'dist' // outputDir: 'dist', // pages:&#123; type:Object,Default:undfind &#125; assetsDir: \"./\", productionSourceMap: false, devServer: &#123; port: 80, // 端口号 host: \"127.0.0.1\", https: false, // https:&#123;type:Boolean&#125; disableHostCheck: true, // open: true, //配置自动启动浏览器 // proxy: 'http://dev.dsp.kuafugame.com/' // 配置跨域处理,只有一个代理 // proxy: &#123; // \"/api\": &#123; // target: \"&lt;url&gt;\", // ws: true, // changeOrigin: true // &#125;, // \"/foo\": &#123; // target: \"&lt;other_url&gt;\" // &#125; // &#125; // 配置多个代理 &#125;,&#125;; 增加额外的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//压缩代码的npm包const CompressionPlugin = require(\"compression-webpack-plugin\")module.exports = &#123; // 判断是在什么环境下运行 publicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"/\", // outputDir: 在npm run build时 生成文件的目录 type:string, default:'dist' // outputDir: 'dist', // pages:&#123; type:Object,Default:undfind &#125; assetsDir: \"./\", productionSourceMap: false, //修改端口号 devServer: &#123; port: 80, // 端口号 host: \"127.0.0.1\", https: false, // https:&#123;type:Boolean&#125; //内网打通 disableHostCheck: true, // open: true, //配置自动启动浏览器 // proxy: 'http://dev.dsp.kuafugame.com/' // 配置跨域处理,只有一个代理 // proxy: &#123; // \"/api\": &#123; // target: \"&lt;url&gt;\", // ws: true, // changeOrigin: true // &#125;, // \"/foo\": &#123; // target: \"&lt;other_url&gt;\" // &#125; // &#125; // 配置多个代理 &#125;, //合并一下webpack的配置 configureWebpack: config =&gt; &#123; //外部引入第三方库，不想打包进vender时 config.externals = &#123; 'vue': 'Vue', 'vue-router': 'VueRouter', 'moment': 'moment', 'axios': 'axios', 'element-ui': 'ELEMENT', &#125; //第三方插件--压缩代码 config.plugins.push(new CompressionPlugin(&#123; test: /\\.js$|\\.html$|.\\css/, //匹配文件名 threshold: 10240, //对超过10k的数据压缩 deleteOriginalAssets: false //不删除源文件 &#125;)) &#125;, //使打包时路由不会预先加载 chainWebpack: config =&gt; &#123; config.plugins.delete(\"prefetch\") &#125;,&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"},{"name":"vue-cli3.0","slug":"vue-cli3-0","permalink":"http://wang-zhibiao.github.io/tags/vue-cli3-0/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"防抖和节流的使用","slug":"vue中防抖和节流的使用","date":"2019-12-11T03:11:11.000Z","updated":"2020-01-03T13:59:52.660Z","comments":true,"path":"2019/12/11/vue中防抖和节流的使用/","link":"","permalink":"http://wang-zhibiao.github.io/2019/12/11/vue中防抖和节流的使用/","excerpt":"","text":"函数防抖（debounce） 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 1234567let timeout = nullexport const debounce = (func, delay) =&gt; &#123; //如果定时器不等于null就清除定时器 if (timeout !== null) clearTimeout(timeout) //设置定时器延时执行函数 timeout = setTimeout(func, delay)//如果在这个delay时间内执行了setTimeout，否者就会被下一个执行所清除，这样就是一个接一个进行执行，但是只执行最后一个&#125; 函数节流(Throttle) 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频。就相当于，一个水龙头在滴水，可能一次性会滴很多滴，但是我们只希望它每隔 500ms 滴一滴水，保持这个频率。即我们希望函数在以一个可以接受的频率重复调用。 123456789101112131415161718192021222324252627282930//初始化函数let timer = nulllet start = 0export const Throttle = (func, wait, trailing) =&gt; &#123; //在函数调用时，获取时间戳 let now = new Date() //判断剩下的等待时间 let remaining = wait - (now - start) console.log(remaining) // 拦截：延迟时间&gt;多次执行间隔时间，执行：多次执行间隔时间&gt;延迟时间 if ((now - start) &gt;= wait) &#123; // 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔 // 但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作 timer &amp;&amp; clearTimeout(timer) timer = null start = now console.log('非频繁操作，点击间隔为：', remaining) //返回回调的函数-》不管this指向 return func() &#125; else if (!timer &amp;&amp; trailing) &#123; // trailing有值时，延时执行func函数 // 频繁操作，第一次设置定时器之后，之后的不会再走到这里创建定时器 // 清除问题，只能在第二有效点击的时候才会清除 timer = setTimeout(() =&gt; &#123; timer = null console.log('频繁操作，定时器延时执行') return func &#125;, wait) &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"node的使用","slug":"node","date":"2019-12-07T04:10:56.000Z","updated":"2019-12-07T15:27:48.530Z","comments":true,"path":"2019/12/07/node/","link":"","permalink":"http://wang-zhibiao.github.io/2019/12/07/node/","excerpt":"","text":"node的跨域解决 123456789101112app.all('*',function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); if (req.method == 'OPTIONS') &#123; res.send(200); /让options请求快速返回/ &#125; else &#123; next(); &#125;&#125;); 获取本地IP 123456789101112function getIPAdress()&#123; var interfaces = require('os').networkInterfaces(); for(var devName in interfaces)&#123; var iface = interfaces[devName]; for(var i=0;i&lt;iface.length;i++)&#123; var alias = iface[i]; if(alias.family === 'IPv4' &amp;&amp; alias.address !== '127.0.0.1' &amp;&amp; !alias.internal)&#123; return alias.address; &#125; &#125; &#125; &#125;","categories":[{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/categories/node/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"http","slug":"http","permalink":"http://wang-zhibiao.github.io/tags/http/"},{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/tags/node/"}],"keywords":[{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/categories/node/"}]},{"title":"前端常用Git命令","slug":"前端常用git命令","date":"2019-11-25T04:00:56.000Z","updated":"2019-12-07T15:28:24.930Z","comments":true,"path":"2019/11/25/前端常用git命令/","link":"","permalink":"http://wang-zhibiao.github.io/2019/11/25/前端常用git命令/","excerpt":"","text":"前端常用Git命令2019-11-03 文章字数: 1,892 阅读时间: 8 分 本文主要讲述前端开发中主要使用的Git相关方法，一部分整理于网上，一部分整理于自己平常使用的。只提供了基础的命令，如果想要更详细解答的小伙伴可以Google命令查询，如有错误，欢迎指出。 常见信息1master: 默认开发分支origin：默认远程版本库Head: 默认开发分支Head^:Head 的父提交 创建新仓库12git initgit init [project-name] # 新建一个目录，并将其初始化为git仓库git clone [url] # 拷贝一个git仓库到本地 配置12345678Git 的配置文件是 .gitconfig，可以放在用户的主目录（全局配置）下或项目目录下（项目配置） 。# 显示当前的 git 配置git config --list # 编辑 Git 配置git config -e [--global] # 设置用来提交代码的用户信息git config [--global] user.name \"[name]\" git config [--global] user.email \"[email address]\" 添加删除文件1234567891011121314# 将指定文件添加到暂存区git add [file1] [file2] ... # 将指定目录添加到暂存区，包括子目录git add [dir] # 将当前目录中的所有文件添加到暂存区git add . # 对同一个文件多次更改，建议分开提交git add -p # 将指定文件从工作区删除，并将本次删除添加到暂存区git rm [file1] [file2] ... # 停止追踪指定的文件，不会删除文件git rm --cached [file] # 对指定文件进行重命名，并添加到暂存区中git mv [file-original] [file-renamed] 代码提交123456789101112# 将暂存区中的文件提交到代码仓库git commit -m [message] # 将指定的文件从暂存区中提交到仓库git commit [file1] [file2] ... -m [message] # 将工作区的更改直接提交到仓库git commit -a # 提交前展示所有的变动git commit -v # 使用新提交代替上次提交，如果代码没有任何变动，将会用于重写上次提交的提交信息git commit --amend -m [message] # 重做上次的提交，并将指定的文件包含其中git commit --amend [file1] [file2] ... 分支相关12345678910111213141516171819202122232425# 列出本地分支git branch # 列出所有远程分支git branch -r # 列出本地和远程的所有分支git branch -a # 新建分支，并留在当前分支git branch [branch-name] # 新建分支，并切换到新建分支git checkout -b [branch-name] # 指向某次提交新建分支git branch [branch] [commit] # 创建一个新分支，并与指定的远程分支建立跟踪关系git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区git checkout [branch-name] # 切换到上一个分支git checkout - # 将本地分支与指定的远程分支建立跟踪关心git branch --set-upstream [branch] [remote-branch]# 合并指定分支与当前分支git merge [branch] # 将指定的提交合并到本地分支git cheery-pick [commit] # 删除本地指定分支git branch -d [branch-name] # 删除远程分支git push origin --delete [branch-name]git push -dr [remote/branch] 标签操作1234567891011121314151617# 列出所有标签git tag# 在当前 tag 上创建一个新标签git tag [tag]# 在指定 tag 上创建一个新标签git tag [tag] [commit]# 删除本地标签git tag -d [tag]# 删除远程标签git push origin :refs/tags/[tagName]# 查看标签信息git show [tag]# 提交指定标签git push [remote] --tags# 创建一个新分支，指向特定的标签git checkout -b [branch] [tag] 查看信息1234567891011121314151617181920212223242526272829303132333435363738394041# 显示有变动的文件git status# 显示当前分支的提交历史git log# 显示提交历史和每次提交的文件git log --stat# 指定关键字搜索提交历史git log -S [keyword]# 显示自某次提交以来的所有更改，一次提交显示一行git log [tag] HEAD --pretty=format:$s# 显示自某次提交以来的所有更改，其提交描述必须符合搜索条件git log [tag] HEAD --grep feature# 显示指定文件的提交历史git log --flollow [file]git whatchanged [file]# 显示与指定文件相关的每个差异git log -p [file]# 显示最近 5 次提交git log -5 --pretty --oneline# 显示所有的提交用户，已提交数目多少排名git shortlog -sn# 显示指定文件何时被何人修改过git blame [file]# 显示暂存区和工作区文件差别git diff# 显示暂存区和上一次提交的差别git diff --cached [file]# 显示工作区和当前分支的最近一次提交的差别git diff HEAD# 显示指定两次提交的差别git diff [first-branch]...[second-branch]# 显示今天提交了多少代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示特定提交的提交信息和更改的内容git show [commit]# 某次提交改动了哪些文件git show --name-only [commit]# 显示某个提交的特定文件的内容git show [commit]:[filename]# 显示当前分支的最新提交git reflog 远程同步1234567891011121314151617181920212223242526272829303132333435363738# 从远程分支下载所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程参考信息git remote show [remote]# 新建一个远程仓库，并命名git remote add [shortname] [url]# 检索远程村粗库的更改，并与本地分支合并git pull [remote] [branch]# 将本地分支提交到远程仓库git push [remote] [branch]# 将当前分支强制提交到远程仓库，即使有冲突存在git push [remote] --force# 将所有分支提交到远程仓库git push [remote] --all#### 撤销操作# 将暂存区中的指定文件还原到工作区，保留文件变动git checkout [file]# 将指定文件从某个提交还原到暂存区和工作区git checkout [commit] [file]# 将暂存区中的所有文件还原到工作区git checkout .# 重置暂存区中的指定文件，与先前的提交保持一致，但保持工作空间的变动不变git reset [file]# 重置暂存区和工作区中的指定文件，并与最近一次提交保持一致，工作空间文件变动不会保留git reset --hard# 重置暂存区，指向指定的某次提交，工作区的内容不会被覆盖git reset [commit]# 重置暂存区和工作区中的指定文件，并与指定的某次提交保持一致，工作区的内容会被覆盖git reset --hard [commit]# 将 HEAD 重置为指定的某次提交，保持暂存区和工作区的内容不变git reset --keep [commit]# 新建新提交以撤销指定的提交git revert [commit]# 暂存为提交的变动，并在稍后移动它们git stashgit stash popgit stash apply 其他12# 生成用于发布的存档git archive","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"Git","slug":"Git","permalink":"http://wang-zhibiao.github.io/tags/Git/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"前端常用rule验证规则","slug":"前端常用rule验证规则","date":"2019-11-24T03:00:56.000Z","updated":"2019-12-07T15:29:18.382Z","comments":true,"path":"2019/11/24/前端常用rule验证规则/","link":"","permalink":"http://wang-zhibiao.github.io/2019/11/24/前端常用rule验证规则/","excerpt":"","text":"前提 在 vue开发中，难免遇到各种表单校验，这里整理了网络上和自己平时高频率用到的一些校验方法。如果错误欢迎指出，后期不断补充更新。 1、是否合法IP地址123456789101112export function validateIP(rule, value,callback) &#123; if(value==''||value==undefined||value==null)&#123; callback(); &#125;else &#123; const reg = /^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])$/; if ((!reg.test(value)) &amp;&amp; value != '') &#123; callback(new Error('请输入正确的IP地址')); &#125; else &#123; callback(); &#125; &#125;&#125; 2、是否手机号码或者固话123456789101112export function validatePhoneTwo(rule, value, callback) &#123; const reg = /^((0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)|(1[34578]\\d&#123;9&#125;))$/;; if (value == '' || value == undefined || value == null) &#123; callback(); &#125; else &#123; if ((!reg.test(value)) &amp;&amp; value != '') &#123; callback(new Error('请输入正确的电话号码或者固话号码')); &#125; else &#123; callback(); &#125; &#125;&#125; 3、是否固话123456789101112export function validateTelphone(rule, value,callback) &#123; const reg =/0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;/; if(value==''||value==undefined||value==null)&#123; callback(); &#125;else &#123; if ((!reg.test(value)) &amp;&amp; value != '') &#123; callback(new Error('请输入正确的固定电话）')); &#125; else &#123; callback(); &#125; &#125;&#125; 4、是否手机号码123456789101112export function validatePhone(rule, value,callback) &#123; const reg =/^[1][3-9][0-9]&#123;9&#125;$/; if(value==''||value==undefined||value==null)&#123; callback(); &#125;else &#123; if ((!reg.test(value)) &amp;&amp; value != '') &#123; callback(new Error('请输入正确的电话号码')); &#125; else &#123; callback(); &#125; &#125;&#125; 5、是否身份证号码123456789101112export function validateIdNo(rule, value,callback) &#123; const reg = /(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/; if(value==''||value==undefined||value==null)&#123; callback(); &#125;else &#123; if ((!reg.test(value)) &amp;&amp; value != '') &#123; callback(new Error('请输入正确的身份证号码')); &#125; else &#123; callback(); &#125; &#125;&#125; 6、是否邮箱123456789101112export function validateEMail(rule, value,callback) &#123; const reg =/^([a-zA-Z0-9]+[-_\\.]?)+@[a-zA-Z0-9]+\\.[a-z]+$/; if(value==''||value==undefined||value==null)&#123; callback(); &#125;else&#123; if (!reg.test(value))&#123; callback(new Error('请输入正确的邮箱')); &#125; else &#123; callback(); &#125; &#125;&#125; 7、合法url1234export function validateURL(url) &#123; const urlregex = /^(https?|ftp):\\/\\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&amp;%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9]?[0-9]))&#123;3&#125;|([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+\\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]&#123;2&#125;))(:[0-9]+)*(\\/($|[a-zA-Z0-9.,?'\\\\+&amp;%$#=~_-]+))*$/; return urlregex.test(url);&#125; 8、验证内容是否包含英文数字以及下划线123456789101112export function isPassword(rule, value, callback) &#123; const reg =/^[_a-zA-Z0-9]+$/; if(value==''||value==undefined||value==null)&#123; callback(); &#125; else &#123; if (!reg.test(value))&#123; callback(new Error('仅由英文字母，数字以及下划线组成')); &#125; else &#123; callback(); &#125; &#125;&#125; 9、自动检验数值的范围1234567891011export function checkMax20000(rule, value, callback) &#123; if (value == '' || value == undefined || value == null) &#123; callback(); &#125; else if (!Number(value)) &#123; callback(new Error('请输入[1,20000]之间的数字')); &#125; else if (value &lt; 1 || value &gt; 20000) &#123; callback(new Error('请输入[1,20000]之间的数字')); &#125; else &#123; callback(); &#125;&#125; 10、验证数字输入框最大数值1234567export function checkMaxVal(rule, value,callback) &#123; if (value &lt; 0 || value &gt; 最大值) &#123; callback(new Error('请输入[0,最大值]之间的数字')); &#125; else &#123; callback(); &#125;&#125; 11、验证是否1-99之间123456789101112131415161718export function isOneToNinetyNine(rule, value, callback) &#123; if (!value) &#123; return callback(new Error('输入不可以为空')); &#125; setTimeout(() =&gt; &#123; if (!Number(value)) &#123; callback(new Error('请输入正整数')); &#125; else &#123; const re = /^[1-9][0-9]&#123;0,1&#125;$/; const rsCheck = re.test(value); if (!rsCheck) &#123; callback(new Error('请输入正整数，值为【1,99】')); &#125; else &#123; callback(); &#125; &#125; &#125;, 0);&#125; 12、验证是否整数123456789101112131415161718export function isInteger(rule, value, callback) &#123; if (!value) &#123; return callback(new Error('输入不可以为空')); &#125; setTimeout(() =&gt; &#123; if (!Number(value)) &#123; callback(new Error('请输入正整数')); &#125; else &#123; const re = /^[0-9]*[1-9][0-9]*$/; const rsCheck = re.test(value); if (!rsCheck) &#123; callback(new Error('请输入正整数')); &#125; else &#123; callback(); &#125; &#125; &#125;, 0);&#125; 13、验证是否整数,非必填123456789101112131415161718export function isIntegerNotMust(rule, value, callback) &#123; if (!value) &#123; callback(); &#125; setTimeout(() =&gt; &#123; if (!Number(value)) &#123; callback(new Error('请输入正整数')); &#125; else &#123; const re = /^[0-9]*[1-9][0-9]*$/; const rsCheck = re.test(value); if (!rsCheck) &#123; callback(new Error('请输入正整数')); &#125; else &#123; callback(); &#125; &#125; &#125;, 1000);&#125; 14、 验证是否是[0-1]的小数12345678910111213141516export function isDecimal(rule, value, callback) &#123; if (!value) &#123; return callback(new Error('输入不可以为空')); &#125; setTimeout(() =&gt; &#123; if (!Number(value)) &#123; callback(new Error('请输入[0,1]之间的数字')); &#125; else &#123; if (value &lt; 0 || value &gt; 1) &#123; callback(new Error('请输入[0,1]之间的数字')); &#125; else &#123; callback(); &#125; &#125; &#125;, 100);&#125; 15、 验证是否是[1-10]的小数,即不可以等于012345678910111213141516export function isBtnOneToTen(rule, value, callback) &#123; if (typeof value == 'undefined') &#123; return callback(new Error('输入不可以为空')); &#125; setTimeout(() =&gt; &#123; if (!Number(value)) &#123; callback(new Error('请输入正整数，值为[1,10]')); &#125; else &#123; if (!(value == '1' || value == '2' || value == '3' || value == '4' || value == '5' || value == '6' || value == '7' || value == '8' || value == '9' || value == '10')) &#123; callback(new Error('请输入正整数，值为[1,10]')); &#125; else &#123; callback(); &#125; &#125; &#125;, 100);&#125; 16、验证是否是[1-100]的小数,即不可以等于012345678910111213141516export function isBtnOneToHundred(rule, value, callback) &#123; if (!value) &#123; return callback(new Error('输入不可以为空')); &#125; setTimeout(() =&gt; &#123; if (!Number(value)) &#123; callback(new Error('请输入整数，值为[1,100]')); &#125; else &#123; if (value &lt; 1 || value &gt; 100) &#123; callback(new Error('请输入整数，值为[1,100]')); &#125; else &#123; callback(); &#125; &#125; &#125;, 100);&#125; 17、验证是否是[0-100]的小数12345678910111213141516export function isBtnZeroToHundred(rule, value, callback) &#123; if (!value) &#123; return callback(new Error('输入不可以为空')); &#125; setTimeout(() =&gt; &#123; if (!Number(value)) &#123; callback(new Error('请输入[1,100]之间的数字')); &#125; else &#123; if (value &lt; 0 || value &gt; 100) &#123; callback(new Error('请输入[1,100]之间的数字')); &#125; else &#123; callback(); &#125; &#125; &#125;, 100);&#125; 18、验证端口是否在[0,65535]之间123456789101112131415161718export function isPort(rule, value, callback) &#123; if (!value) &#123; return callback(new Error('输入不可以为空')); &#125; setTimeout(() =&gt; &#123; if (value == '' || typeof(value) == undefined) &#123; callback(new Error('请输入端口值')); &#125; else &#123; const re = /^([0-9]|[1-9]\\d|[1-9]\\d&#123;2&#125;|[1-9]\\d&#123;3&#125;|[1-5]\\d&#123;4&#125;|6[0-4]\\d&#123;3&#125;|65[0-4]\\d&#123;2&#125;|655[0-2]\\d|6553[0-5])$/; const rsCheck = re.test(value); if (!rsCheck) &#123; callback(new Error('请输入在[0-65535]之间的端口值')); &#125; else &#123; callback(); &#125; &#125; &#125;, 100);&#125; 19、验证端口是否在[0,65535]之间，非必填,isMust表示是否必填123456789101112131415161718export function isCheckPort(rule, value, callback) &#123; if (!value) &#123; callback(); &#125; setTimeout(() =&gt; &#123; if (value == '' || typeof(value) == undefined) &#123; //callback(new Error('请输入端口值')); &#125; else &#123; const re = /^([0-9]|[1-9]\\d|[1-9]\\d&#123;2&#125;|[1-9]\\d&#123;3&#125;|[1-5]\\d&#123;4&#125;|6[0-4]\\d&#123;3&#125;|65[0-4]\\d&#123;2&#125;|655[0-2]\\d|6553[0-5])$/; const rsCheck = re.test(value); if (!rsCheck) &#123; callback(new Error('请输入在[0-65535]之间的端口值')); &#125; else &#123; callback(); &#125; &#125; &#125;, 100);&#125; 20、小写字母1234export function validateLowerCase(val) &#123; const reg = /^[a-z]+$/; return reg.test(val);&#125; 22、两位小数验证1234567const validateValidity = (rule, value, callback) =&gt; &#123; if (!/(^[1-9]([0-9]+)?(\\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\\.[0-9]([0-9])?$)/.test(value)) &#123; callback(new Error('最多两位小数！！！')); &#125; else &#123; callback(); &#125;&#125; 23、是否大写字母1234export function validateUpperCase(val) &#123; const reg = /^[A-Z]+$/; return reg.test(val);&#125; 24、是否大小写字母1234export function validatAlphabets(val) &#123; const reg = /^[A-Za-z]+$/; return reg.test(val);&#125; 25、密码校验12345678910export const validatePsdReg = (rule, value, callback) =&gt; &#123; if (!value) &#123; return callback(new Error('请输入密码')) &#125; if (!/^(?![\\d]+$)(?![a-zA-Z]+$)(?![^\\da-zA-Z]+$)([^\\u4e00-\\u9fa5\\s])&#123;6,20&#125;$/.test(value)) &#123; callback(new Error('请输入6-20位英文字母、数字或者符号（除空格），且字母、数字和标点符号至少包含两种')) &#125; else &#123; callback() &#125;&#125; 26、中文校验12345678910export const validateContacts = (rule, value, callback) =&gt; &#123; if (!value) &#123; return callback(new Error('请输入中文')) &#125; if (!/^[\\u0391-\\uFFE5A-Za-z]+$/.test(value)) &#123; callback(new Error('不可输入特殊字符')) &#125; else &#123; callback() &#125;&#125; 27、 账号校验12345678910export const validateCode = (rule, value, callback) =&gt; &#123; if (!value) &#123; return callback(new Error('请输入账号')) &#125; if (!/^(?![0-9]*$)(?![a-zA-Z]*$)[a-zA-Z0-9]&#123;6,20&#125;$/.test(value)) &#123; callback(new Error('账号必须为6-20位字母和数字组合')) &#125; else &#123; callback() &#125;&#125; 28 、纯数字校验123456789101112export const validateNumber = (rule, value, callback) =&gt; &#123; let numberReg = /^\\d+$|^\\d+[.]?\\d+$/ if (value !== '') &#123; if (!numberReg.test(value)) &#123; callback(new Error('请输入数字')) &#125; else &#123; callback() &#125; &#125; else &#123; callback(new Error('请输入值')) &#125;&#125; 29、最多一位小数1234567const onePoint = (rule, value, callback) =&gt; &#123; if (!/^[0-9]+([.]&#123;1&#125;[0-9]&#123;1&#125;)?$/.test(value)) &#123; callback(new Error('最多一位小数！！！')); &#125; else &#123; callback(); &#125;&#125;; 使用方法： 在使用地方直接 import 引入，然后在 rules 校验中加入即可。 1属性: [&#123; validator: validatePass, trigger: \"blur\" &#125;], 其他","categories":[{"name":"vue基础","slug":"vue基础","permalink":"http://wang-zhibiao.github.io/categories/vue基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"},{"name":"rule","slug":"rule","permalink":"http://wang-zhibiao.github.io/tags/rule/"}],"keywords":[{"name":"vue基础","slug":"vue基础","permalink":"http://wang-zhibiao.github.io/categories/vue基础/"}]},{"title":"http编码","slug":"http编码","date":"2019-11-15T04:10:56.000Z","updated":"2019-12-07T15:25:07.978Z","comments":true,"path":"2019/11/15/http编码/","link":"","permalink":"http://wang-zhibiao.github.io/2019/11/15/http编码/","excerpt":"","text":"http 1**(信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970712**(响应成功)：表示动作被成功接收、理解和接受200——表明该请求被成功地完成，所请求的资源发送回客户端201——提示知道新文件的URL202——接受和处理、但处理未完成203——返回信息不确定或不完整204——请求收到，但返回信息为空205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件206——服务器已经完成了部分用户的GET请求3**(重定向类)：为了完成指定的动作，必须接受进一步处理300——请求的资源可在多处得到301——本网页被永久性转移到另一个URL302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。303——建议客户访问其他URL或访问方式304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用305——请求的资源必须从服务器指定的地址得到306——前一版本HTTP中使用的代码，现行版本中不再使用307——申明请求的资源临时性删除4**(客户端错误类)：请求包含错误语法或不能正确执行400——客户端请求有语法错误，不能被服务器所理解401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用HTTP 401.1 - 未授权：登录失败&amp;emsp;&amp;emsp;HTTP 401.2 - 未授权：服务器配置问题导致登录失败&amp;emsp;&amp;emsp;HTTP 401.3 - ACL 禁止访问资源&amp;emsp;&amp;emsp;HTTP 401.4 - 未授权：授权被筛选器拒绝HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败402——保留有效ChargeTo头响应403——禁止访问，服务器收到请求，但是拒绝提供服务HTTP 403.1 禁止访问：禁止可执行访问&amp;emsp;&amp;emsp;HTTP 403.2 - 禁止访问：禁止读访问&amp;emsp;&amp;emsp;HTTP 403.3 - 禁止访问：禁止写访问&amp;emsp;&amp;emsp;HTTP 403.4 - 禁止访问：要求 SSL&amp;emsp;&amp;emsp;HTTP 403.5 - 禁止访问：要求 SSL 128&amp;emsp;&amp;emsp;HTTP 403.6 - 禁止访问：IP 地址被拒绝&amp;emsp;&amp;emsp;HTTP 403.7 - 禁止访问：要求客户证书&amp;emsp;&amp;emsp;HTTP 403.8 - 禁止访问：禁止站点访问&amp;emsp;&amp;emsp;HTTP 403.9 - 禁止访问：连接的用户过多&amp;emsp;&amp;emsp;HTTP 403.10 - 禁止访问：配置无效&amp;emsp;&amp;emsp;HTTP 403.11 - 禁止访问：密码更改&amp;emsp;&amp;emsp;HTTP 403.12 - 禁止访问：映射器拒绝访问&amp;emsp;&amp;emsp;HTTP 403.13 - 禁止访问：客户证书已被吊销&amp;emsp;&amp;emsp;HTTP 403.15 - 禁止访问：客户访问许可过多&amp;emsp;&amp;emsp;HTTP 403.16 - 禁止访问：客户证书不可信或者无效HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL405——用户在Request-Line字段定义的方法不允许406——根据用户发送的Accept拖，请求资源不可访问407——类似401，用户必须首先在代理服务器上得到授权408——客户端没有在用户指定的饿时间内完成请求409——对当前资源状态，请求不能完成410——服务器上不再有此资源且无进一步的参考地址411——服务器拒绝用户定义的Content-Length属性请求412——一个或多个请求头字段在当前请求中错误413——请求的资源大于服务器允许的大小414——请求的资源URL长于服务器允许的长度415——请求资源不支持请求项目格式416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。5**(服务端错误类)：服务器不能正确执行一个正确的请求HTTP 500 - 服务器遇到错误，无法完成请求&amp;emsp;&amp;emsp;HTTP 500.100 - 内部服务器错误 - ASP 错误&amp;emsp;&amp;emsp;HTTP 500-11 服务器关闭&amp;emsp;&amp;emsp;HTTP 500-12 应用程序重新启动&amp;emsp;&amp;emsp;HTTP 500-13 - 服务器太忙&amp;emsp;&amp;emsp;HTTP 500-14 - 应用程序无效&amp;emsp;&amp;emsp;HTTP 500-15 - 不允许请求 global.asa&amp;emsp;&amp;emsp;Error 501 - 未实现HTTP 502 - 网关错误HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"http","slug":"http","permalink":"http://wang-zhibiao.github.io/tags/http/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"vue的开发过程","slug":"vue技术","date":"2019-11-01T14:13:14.000Z","updated":"2020-04-14T02:25:37.076Z","comments":true,"path":"2019/11/01/vue技术/","link":"","permalink":"http://wang-zhibiao.github.io/2019/11/01/vue技术/","excerpt":"","text":"子组件传出单个参数时：1234// 子组件this.$emit('test',this.param)// 父组件@test='test($event,userDefined)' 子组件传出多个参数时：1234// 子组件this.$emit('test',this.param1，this.param2, this.param3)// 父组件 arguments 是以数组的形式传入@test='test(arguments,userDefined)' 对于异步请求的异常处理12345678910methods: &#123; async getUserPageData() &#123; try &#123; //请求 const res = await Promise()/api请求 &#125; catch(error) &#123; // 失败的情况写在catch中 &#125; &#125;&#125; handler方法和immediate属性这里 watch 的一个特点是，最初绑定的时候是不会执行的，要等到 firstName 改变时才执行监听计算。那我们想要一开始就让他最初绑定的时候就执行改怎么办呢？我们需要修改一下我们的 watch 写法，修改过后的 watch 代码如下： 12345678910watch: &#123; firstName: &#123; handler(newName, oldName) &#123; this.fullName = newName + ' ' + this.lastName; &#125;, // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法 immediate: true &#125;&#125;复制代码 注意到handler了吗，我们给 firstName 绑定了一个handler方法，之前我们写的 watch 方法其实默认写的就是这个handler，Vue.js会去处理这个逻辑，最终编译出来其实就是这个handler。 而immediate:true代表如果在 wacth 里声明了 firstName 之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。 解决导航栏重复点击跳转报错报错1234const originalPush = Router.prototype.push;Router.prototype.push = function push(location) &#123; return originalPush.call(this, location).catch(err =&gt; err);&#125;; 在组件中监听滚动事件1234567891011121314151617181920mounted() &#123; window.addEventListener(\"scroll\", this.handleScroll, true); &#125;, methods: &#123; handleScroll() &#123; var scrollTop = document.querySelector(\"#main\").scrollTop; var offsetTop = document.querySelector(\"#component\").offsetTop; var clientHeight = document.querySelector(\"#component\").clientHeight; //if (scrollTop - offsetTop - clientHeight + 500 &gt; 0) &#123; // this.ForecastFixed = false; // &#125; else if (scrollTop &gt; offsetTop - 50) &#123; // this.ForecastFixed = true; //&#125; else &#123; // this.ForecastFixed = false; // &#125; &#125;, &#125; beforeDestroy() &#123; window.removeEventListener(\"scroll\", this.handleScroll, true); &#125;, 在 window.addEventListener 的第三个参数加上true，默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。beforeDestroy销毁也需要加上此属性 vue中使用的防抖和节流定义utils.js 1234567891011121314151617181920212223//函数防抖（debounce）let timeout = nulllet timer = nulllet start = 0export const debounce = (func, delay) =&gt; &#123; if (timeout !== null) clearTimeout(timeout) timeout = setTimeout(func, delay)&#125;//函数节流(Throttle)export const Throttle = (func, wait, trailing) =&gt; &#123; let now = new Date() if ((now - start) &gt;= wait) &#123; timer &amp;&amp; clearTimeout(timer) timer = null start = now return func() &#125; else if (!timer &amp;&amp; trailing) &#123; timer = setTimeout(() =&gt; &#123; timer = null return func &#125;, wait) &#125;&#125; 在组件中使用 12345678910import &#123;debounce,Throrrle&#125; from \"@/utils.js\" debounce(() =&gt; &#123; //执行的防抖函数，鼠标移动事件，输入框改变事件，请求报错事件 if (error.response.status === 400 || String(error).indexOf('code 400') !== -1) &#123; debounce(() =&gt; &#123; Message.error(error.response.data.message) &#125;, 100) return Promise.reject(error.response.data) &#125; &#125;, 1000); this.$set 为了设置一个数组的新属性添加在vm上进行响应式 Proxy（vue3的响应拦截）1234new Proxy(data, &#123; get(key) &#123; &#125;, set(key, value) &#123; &#125;,&#125;) defineProperty(vue2的响应拦截)1234Object.defineProperty(data, 'count', &#123; get() &#123;&#125;, set() &#123;&#125;,&#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"}],"keywords":[{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/categories/vue/"}]},{"title":"commonJS以及ES6的引入方法","slug":"commonJS以及ES6的引入方法","date":"2019-10-10T04:10:56.000Z","updated":"2019-12-07T15:23:29.268Z","comments":true,"path":"2019/10/10/commonJS以及ES6的引入方法/","link":"","permalink":"http://wang-zhibiao.github.io/2019/10/10/commonJS以及ES6的引入方法/","excerpt":"","text":"commonJS，定义wang.js 123456function wang()&#123; //封装的函数 console.log(\"wang\")&#125;//第一种module.exports = &#123;wang&#125; commonJS，引入(路径自定义) 123456789//引入var wang = require('./wang.js');//使用wang.wang();//其他引入var &#123;wang&#125; = require('./wang.js');//使用wang(); ES6,定义wang.js 1234export function wang()&#123; //封装的函数 console.log(\"wang\")&#125; ES6,引入wang.js 1234//引入import &#123;wang&#125; from \"./wang.js\"//使用wang();","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"开启你的博客创建之旅","slug":"我的博客创建","date":"2019-09-14T14:22:56.000Z","updated":"2019-09-14T15:05:08.017Z","comments":true,"path":"2019/09/14/我的博客创建/","link":"","permalink":"http://wang-zhibiao.github.io/2019/09/14/我的博客创建/","excerpt":"","text":"搭建环境 搭建之前首先需要安装nodejs 和 Git 注册github账号,创建以” github账户名.github.io “命名的仓库 学习git的基本操作 友情链接 使用node 安装hexo的包 1npm install -g hexo-cli 创建本地博客文件 新建文件 鼠标右键打开 git bash here hexo 初始化博客本地文件，使用以下命令 12hexo inithexo install 使用npm下载插件链接git仓库 1npm install hexo-deployer-git --save 修改博客文件下_config.yml 仓库地址的修改 博客作者的配置 提交博客文件到github仓库 1hexo g -d hexo配置完成后的界面","categories":[{"name":"blog","slug":"blog","permalink":"http://wang-zhibiao.github.io/categories/blog/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/tags/node/"},{"name":"hexo","slug":"hexo","permalink":"http://wang-zhibiao.github.io/tags/hexo/"}],"keywords":[{"name":"blog","slug":"blog","permalink":"http://wang-zhibiao.github.io/categories/blog/"}]},{"title":"+++post","slug":"+++post","date":"2019-09-11T16:10:56.000Z","updated":"2020-02-28T10:12:41.841Z","comments":true,"path":"2019/09/12/+++post/","link":"","permalink":"http://wang-zhibiao.github.io/2019/09/12/+++post/","excerpt":"","text":"","categories":[{"name":"any","slug":"any","permalink":"http://wang-zhibiao.github.io/categories/any/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"any","slug":"any","permalink":"http://wang-zhibiao.github.io/tags/any/"}],"keywords":[{"name":"any","slug":"any","permalink":"http://wang-zhibiao.github.io/categories/any/"}]},{"title":"理想视口","slug":"理想视口","date":"2019-09-11T16:10:56.000Z","updated":"2019-09-14T15:06:50.590Z","comments":true,"path":"2019/09/12/理想视口/","link":"","permalink":"http://wang-zhibiao.github.io/2019/09/12/理想视口/","excerpt":"","text":"标准的理想视口如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1,minimum-scale=1,user-scalable=no\"&gt; 普通的理想视口如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; 标准的写法比普通的写法 多了一些设置。 使用标准的写法可以一些莫名其妙的问题 （触屏事件中的clientX/Y和pageX/Y的演示） 使用普通的写法可能会出现一些莫名其妙的问题 在写项目中建议使用标准的写法 参数的描述 了解即可 meta标签用来描述或设置一个HTML网页文档的属性 content 要设置或者描述的内容 width 设置视口的宽度 device-width等于屏幕的宽度 initial-scale 页面打开的时候视口放大的倍数 值:1 user-scalable 是否允许用户缩放页面 值：no maximum-scale 如果允许放大的话 最大放大多少倍 值 ：1 minimum-scale 如果允许放大的话 最小放大多少倍 值 ：1","categories":[{"name":"布局","slug":"布局","permalink":"http://wang-zhibiao.github.io/categories/布局/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://wang-zhibiao.github.io/tags/html/"}],"keywords":[{"name":"布局","slug":"布局","permalink":"http://wang-zhibiao.github.io/categories/布局/"}]},{"title":"Ajax请求","slug":"Ajax","date":"2019-07-21T16:10:56.000Z","updated":"2019-08-11T12:07:29.369Z","comments":true,"path":"2019/07/22/Ajax/","link":"","permalink":"http://wang-zhibiao.github.io/2019/07/22/Ajax/","excerpt":"","text":"AJAX一种异步数据交互技术 解决的问题： 提高用户的体验 现在开发里面，使用ajax实现前后端的完全分离开发 ajax使用的四个步骤 1234567891011121314// 1 创建异步对象var xhr = new XMLHttpRequest();// 2 指定请求的方式和请求的地址xhr.open(请求方式,目标地址);// 3 发送请求xhr.send();// 4 注册状态变化的监听(事件)xhr.onreadystatechange = function()&#123; // 关注最终的结果 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; //把响应体获取 console.log(xhr.responseText); &#125;&#125; 异步对象的readyState属性，是一个从0-4不断变化的数字，每个数字代表一个状态，我们只需要大概了解一下，关心最终的结果就可以了","categories":[{"name":"Ajax","slug":"Ajax","permalink":"http://wang-zhibiao.github.io/categories/Ajax/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"Ajax","slug":"Ajax","permalink":"http://wang-zhibiao.github.io/tags/Ajax/"}],"keywords":[{"name":"Ajax","slug":"Ajax","permalink":"http://wang-zhibiao.github.io/categories/Ajax/"}]},{"title":"node开启服务器","slug":"node基本服务器创建","date":"2019-07-11T16:10:56.000Z","updated":"2019-08-10T12:35:40.235Z","comments":true,"path":"2019/07/12/node基本服务器创建/","link":"","permalink":"http://wang-zhibiao.github.io/2019/07/12/node基本服务器创建/","excerpt":"","text":"搭建一个nodejs服务器nodejs搭建服务器，需要4步： 1.引入http模块 1var http = require('http');// 语法就是 require(模块名称) 2.创建服务器对象 1var server = http.createServer(); 3.监听ip和端口 12345server.listen(端口,ip,回调函数);// 例如server.listen(8080,'127.0.0.1',function()&#123; 提示用户，可以通过什么地址访问服务器&#125;); 4.监听浏览器请求服务器的事件 123456server.on('request',function(req,res)&#123; // req - request - 请求对象，里面有请求所包含的数据 -请求头、请求体... // res - response - 响应对象，里面包含的是响应的数据 - 响应头、响应体... // 在事件处理程序里面把数据返回给浏览器 res.end(数据);&#125;) 12345678910111213141516var http = require('http');// 引入http模块,养成一个习惯，在node里面，要使用什么功能，就需要引入对应的模块// 接着创建服务器对象var server = http.createServer();// 接着为了可以 让浏览器找到我，监听ip和端口// server.listen(端口,ip,回调函数) // 其实ip和端口都是可以省略的，如果端口省略，默认是80，如果ip省略，默认是127.0.0.1server.listen(8080,'127.0.0.1',function()&#123; console.log('服务器已经开启，请通过 http://127.0.0.1:8080 访问');&#125;);// 开始监听浏览器的请求server.on('request',function(req,res)&#123; // 在请求事件的处理程序里面，返回数据给浏览器 setTimeout(function()&#123; res.end('hello world'); &#125;,3000);&#125;);","categories":[{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/categories/node/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/tags/node/"}],"keywords":[{"name":"node","slug":"node","permalink":"http://wang-zhibiao.github.io/categories/node/"}]},{"title":"高德地图与vue的使用","slug":"高德地图","date":"2019-06-26T02:00:56.000Z","updated":"2019-07-25T02:00:33.243Z","comments":true,"path":"2019/06/26/高德地图/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/26/高德地图/","excerpt":"","text":"首先介绍一下vue与高德 之间的联系vue与数据息息相关，而且，vue的数据使用是通过this来调用 也是把数据挂载到了vm实例身上，调用时，使用this调用vm实例上挂载的数据及其方便，所以在vue的使用时我们偶尔也会碰到this指向不明，指向的不是vm实例导致 数据输出undefined 高德的API使用简单，我们可以思考：与vue的this的挂载使用 初始化地图调用地图接口-同步1234&lt;script type=\"text/javascript\" src=\"https://webapi.amap.com/maps?v=1.4.15&amp;key=你个人的key，下面有高德与百度的链接\" &gt;&lt;/script&gt; 高德地图 百度地图 调用接口-异步12345678window.onLoad = function()&#123; var map = new AMap.Map('container');&#125;var url = 'https://webapi.amap.com/maps?v=1.4.15&amp;key=您申请的key值&amp;callback=onLoad';var jsapi = doc.createElement('script');jsapi.charset = 'utf-8';jsapi.src = url;document.head.appendChild(jsapi); 两者各有优缺，看场景使用 官方的使用12345var map = new AMap.Map('container', &#123; zoom:11,//级别 center: [116.397428, 39.90923],//中心点坐标 viewMode:'3D'//使用3D视图&#125;); 与vue结合使用1234567891011data()&#123; return &#123; map:null &#125;&#125;this.map = new AMap.Map(\"hotelMap\", &#123; zoom: 11, //级别 center: [116.397428, 39.90923], //中心点坐标 viewMode: \"3D\" //使用3D视图 &#125;); 两者的区别只是this与var的不同，但是实际上var 是定义一个全局的map变量让我们使用，我们在哪个函数都能使用map 因为他是全局的变量 this却是让map这个变量挂载到vm实例身上，所以你需要在data里初始化map 你的地图需要描点与打开信息窗体时123456789data() &#123; return &#123; MapData:[], // 后台数据初始化 map: null, //地图初始化 infoWindow // 信息窗体 markers: null, // 点的数据 center: [118.796623, 32.059352] // 地图中心点 &#125;; &#125;, 在vue调用地图时最好使用定时器调用，因为地图加载需要时间 123setTimeout(() =&gt; &#123; this.setMapInfo(); &#125;, 3000); 生成多个描点 需要后台返回经纬度信息，下面使用的数据已经是后台返回的带有经纬度信息location：{ longitude：经度 ，latitude：纬度} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546methods:&#123; setMapInfo() &#123; const &#123;location&#125; = this.MapData[3] //数据的第三条数据当地图中心 //设置地图中心点 this.center = [location.longitude,location.latitude] this.map = new AMap.Map(\"hotelMap\", &#123; //初始化地图 zoom: 10, //级别 center: this.center, //中心点坐标 viewMode: \"3D\" //使用3D视图 &#125;); //数据的循环 让点循环生成 this.MapData.forEach(v =&gt; &#123; //生成多个坐标点 this.setMarker(v.area, [v.location.longitude, v.location.latitude], v); //第一个v.area 是点的标识，第二个是一个经纬度数据，第三个是v 后台的其他信息 ==》可以直接写参数v 其他的在setMarker &#125;); &#125;, //添加点标记 setMarker(markers, position, data) &#123; //点的设置 this.markers = new AMap.Marker(&#123; //点的内容，也是你在地图中显示的点的样式 你可以是一张图片 可以是圆，多边形 content: `&lt;div style=\"width:20px;height:28px;text-align:center;\" class=\"el-icon-location\"&gt;&lt;/div&gt;`, //点的经纬度 也是位置 position: position, ///点也有偏移 offset: new AMap.Pixel(-17, -42), // 相对于基点的偏移位置 //地图一定要绑定在你想使用的地图上 也就是说在一个页面不一定只有一个地图 map: this.map //把点标记绑在前面初始化的 map_ 上，否则不显示 &#125;); //注册点的触发事件，触发信息窗体 this.markers.on(\"mousemove\", () =&gt; &#123; //定义信息窗体的div内容 this.content = `&lt;div&gt;&lt;img src=\"$&#123;data.photos&#125;\" style=\"width:100px; height:50px;margin:0 auto\"&gt; &lt;div&gt;&lt;b style=\"color:#666\"&gt;$&#123;data.name&#125;&lt;/b&gt;` //重新设置信息窗体 this.infoWindow = new AMap.InfoWindow(&#123; //信息窗体相对于基点=》也就是经纬度的点 偏移的xy轴量 offset: new AMap.Pixel(-5, -50), content: this.content //传入 dom 对象，或者 html 字符串 &#125;); //设置信息窗体需要打开 ，参数是 这个地图this.map 和 position 打开的位置 this.infoWindow.open(this.map, position); &#125;); &#125;,&#125; 实际效果 当你想要在地图外响应地图时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;template&gt; &lt;div class=\"traffic\"&gt; &lt;ul&gt; &lt;li v-for=\"(item,index) in sceneryMapdata\" :key=\"index\" style=\"cursor:pointer;\" @mousemove=\"choose(item)\"&gt; &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;item.biz_ext.rating&#125;&#125;公里&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;data() &#123; return &#123; //地图的标签 activeName:\"first\", // 地图的数据 sceneryMapdata:null, //地图加载时间 loading:true, //地图窗体信息 content: \"高级酒店\", map: null, markers: null, infoWindow: null, center: [118.796623, 32.059352] &#125;; &#125;,methods: &#123; //触发地图的点 choose(data)&#123; let temp = data.location.split(\",\"); temp = [temp[0]-0,temp[1]-0] this.content = data.name this.infoWindow = new AMap.InfoWindow(&#123; offset: new AMap.Pixel(-5, -50), content: this.content //传入 dom 对象，或者 html 字符串 &#125;); this.infoWindow.open(this.map, temp); &#125;, //添加点标记 setMarker(markers, position, data) &#123; this.markers = new AMap.Marker(&#123; content: `&lt;div style=\"width:20px;height:28px;text-align:center;\" class=\"el-icon-location\"&gt;&lt;/div&gt;`, position: position, offset: new AMap.Pixel(-17, -42), // 相对于基点的偏移位置 map: this.map //把点标记绑在前面初始化的 map_ 上，否则不显示 &#125;); AMap.event.addListener(this.markers,\"mousemove\", ()=&gt;&#123; this.content = data.name; this.infoWindow = new AMap.InfoWindow(&#123; offset: new AMap.Pixel(-5, -50), content: this.content //传入 dom 对象，或者 html 字符串 &#125;); this.infoWindow.open(this.map, position); &#125;); &#125;, setMapInfo() &#123; const &#123;location&#125; = this.sceneryMapdata[3] //重新设置地图中心点 const temp = location.split(\",\"); this.center = [temp[0]-0,temp[1]-0] this.map = new AMap.Map(\"detailMap\", &#123; zoom: 14, //级别 center: this.center, //中心点坐标 viewMode: \"3D\" //使用3D视图 &#125;); this.sceneryMapdata.forEach(v =&gt; &#123; //生成多个坐标点 let str = v.location.split(\",\"); this.setMarker(v.name, [str[0]-0,str[1]-0], v); &#125;); &#125;, //请求数据 getMapdata()&#123; this.$axios(&#123; url:`https://restapi.amap.com/v3/place/text`, params:&#123; keyword:'', location:\"118.732841,32.077242\", city:\"南京市\", types:\"风景名胜\", output:'json', page:1, offset:10, key:'key私人定制' //=》 这个key是一个web服务 当你创建key可以选择 &#125; &#125;).then(res=&gt;&#123; this.sceneryMapdata = res.data.pois &#125;) &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.setMapInfo(); &#125;, 3000); //请求数据 this.getMapdata() &#125;&#125;;","categories":[{"name":"vue-高德地图","slug":"vue-高德地图","permalink":"http://wang-zhibiao.github.io/categories/vue-高德地图/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue高德地图","slug":"vue高德地图","permalink":"http://wang-zhibiao.github.io/tags/vue高德地图/"}],"keywords":[{"name":"vue-高德地图","slug":"vue-高德地图","permalink":"http://wang-zhibiao.github.io/categories/vue-高德地图/"}]},{"title":"JS执行上下文","slug":"js上下文执行","date":"2019-06-24T19:10:56.000Z","updated":"2019-07-24T09:55:58.262Z","comments":true,"path":"2019/06/25/js上下文执行/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/25/js上下文执行/","excerpt":"","text":"在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。执行上下文类型分为：全局执行上下文函数执行上下文执行上下文创建过程中，需要做以下几件事:创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。确定this的值，即 ResolveThisBinding作用域作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。(with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)作用域分为：全局作用域函数作用域块级作用域JS执行上下文栈(后面简称执行栈)执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。规则如下：首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 12345678910first()&#123; console.log('first')&#125;second()&#123; first()&#125;third()&#123; second()&#125;third()","categories":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}]},{"title":"JS全局污染","slug":"JS全局污染","date":"2019-06-20T11:50:59.000Z","updated":"2019-07-01T01:20:12.648Z","comments":true,"path":"2019/06/20/JS全局污染/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/20/JS全局污染/","excerpt":"","text":"所谓全局变量污染 ：定义多个全局变量，函数，对象挂载在window上，如果重复使用则造成变量冲突 如果定义一个全局变量则会在window上挂载这个变量，所有的函数，对象，引用此js文件的都可以使用， 1234567891011&lt;script&gt; var a = 10; console.log(window);&lt;/script&gt;//输出Windowa: 10alert: ƒ alert()applicationCache: ApplicationCache &#123;status: 0, oncached: null, onchecking: null, ondownloading: null, onerror: null, …&#125;。。。。。。。 污染如同衣物沾上污渍，笔墨落入清水。 全局window是大家都能使用，如果在全局挂载变量太多，难免会调用重复的变量，改变其属性或值。 在开发中，多人共同开发，每个人的代码习惯不同，命名方法不同，如果其他人命名一个变量ID，那么，在调用ID时会改变上一个人的ID导致不是自己想要的ID。 123456789101112131415161718192021222324//developer_first.js&lt;script&gt; var ID = 10; console.log(ID);&lt;/script&gt;//developer_second.js&lt;script&gt; var ID = 2; console.log(ID);&lt;/script&gt;//developer_thirdly.js&lt;script&gt; var ID = 4; console.log(ID);&lt;/script&gt;//在主文件中调用&lt;head&gt;&lt;script src=\"developer_first.js\"&gt;&lt;/script&gt;&lt;script src=\"developer_second.js\"&gt;&lt;/script&gt; &lt;script src=\"developer_thirdly.js\"&gt;&lt;/script&gt; //最后的&lt;/head&gt;//=&gt;输出 4 4 4 ID会使用最后调用的js文件 为了避免全局污染，应慎重使用全局变量。了解模块化，或者let 定义的let不在window里 在script内有效 或者函数{}内有效，形成块级作用域","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"js常见的继承方式","slug":"js的六种继承方式","date":"2019-06-20T01:10:56.000Z","updated":"2019-07-14T01:29:05.728Z","comments":true,"path":"2019/06/20/js的六种继承方式/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/20/js的六种继承方式/","excerpt":"","text":"js中的继承：在js中的继承只是属性和方法的继承 一般没有所谓的多态性，js的继承只是为了使代码的复用性更高。 js的继承是通过prototype来继承的1 原型链继承这种方式关键在于:**子类型的原型为父类型的一个实例对象。 12345678910111213141516171819 //父类型 function Person(name, age) &#123; this.name = name, this.age = age, this.play = [1, 2, 3] this.setName = function () &#123;&#125; &#125; Person.prototype.setAge = function () &#123;&#125; //子类型 function Student(price) &#123; this.price = price this.setScore = function () &#123;&#125; &#125;// Student.prototype.sayHello = function () &#123; &#125;//在这里写子类的原型方法和属性是无效的，//因为会改变原型的指向，所以应该放到重新指定之后 Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象 var s1 = new Student(15000) var s2 = new Student(14000) console.log(s1,s2) 说明：定义一个Person父类型拥有对象和方法 Person.prototype.setAge = function () {} 这是一种在外部定义的一个在prototype原型上的方法 原理：每个function身上都有一个原型 在原型身上可以挂载方法和属性 Student.prototype = new Person() Student原型指向Person的实例对象，所以子类的实例就可以通过proto__访问到 Student.prototype 也就是Person的实例，这样就可以访问到父类的私有方法，然后再通过__proto指向父类的prototype就可以获得到父类原型上的方法。于是做到了将父类的私有、公有方法和属性都当做子类的公有属性 弊端：子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法 如果父类的私有属性有引用类型，子类继承的是这个父类的引用地址 如果子类操作父类的引用类型就会导致引用类型改变详情请看 js数据类型 我们需要在子类中添加新的方法或者是重写父类的方法时候，切记一定要放到替换原型的语句之后 2 借用构造函数继承这种方式关键在于:在子类型构造函数中通用call()调用父类型构造函数 12345678910111213function Person(name, age) &#123; this.name = name, this.age = age, this.setName = function () &#123;&#125;&#125;Person.prototype.setAge = function () &#123;&#125;function Student(name, age, price) &#123; Person.call(this, name, age) // 相当于: this.Person(name, age) /*this.name = name this.age = age*/ this.price = price&#125;var s1 = new Student('Tom', 20, 15000) 说明：在Student中构造Person的属性和方法，但是只是实现部分继承，如果父类的属性和方法太多，继承麻烦。但是解决了引用类型的问题因为这个构造函数是再次创建实例 弊端：子类的实例是根据父类的实例重新构造的，只能继承父类的实例属性和方法，不能继承原型属性和方法 代码复用性弱，每个子类都是父类的实例函数副本，影响性能 3 原型链+借用构造函数的组合继承这种方式关键在于:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 。 1234567891011121314151617181920212223function Person (name, age) &#123; this.name = name, this.age = age, this.setAge = function () &#123; &#125;&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //第一次调用构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;// 令Student的原型指向Person的实例Student.prototype = new Person()Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的Student.prototype.sayHello = function () &#123; &#125;var s1 = new Student('Tom', 20, 15000)var s2 = new Student('Jack', 22, 14000)console.log(s1)console.log(s1.constructor) //Studentconsole.log(p1.constructor) //Person 说明：在子类中调用构造函数生成实例对象但是只是包含属性，在子类的原型链上继承Person的实例，再次使用构造函数，是刚继承的实例构造成一个新的实例赋值 这个实例属于Student 构造函数（constructor） –字面意思，能构造一个实例的函数 弊端：无论如何都会调用两次构造函数，创建子类的原型和子类构造函数内部 4 组合继承的优化-原型指向这种方式关键在于 通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免的组合继承的缺点 12345678910111213141516171819function Person (name, age) &#123; this.name = name, this.age = age, this.setAge = function () &#123; &#125;&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;//原型的赋值Student.prototype = Person.prototypeStudent.prototype.sayHello = function () &#123; &#125;var s1 = new Student('Tom', 20, 15000)console.log(s1) 说明：原型的赋值会让两个类指向同一个对象 ，与上面的区别在于一个是构造函数的赋值 这是原型的赋值，不会生成两次实例 弊端：父类指向不明，都是原型的赋值 同一个对象，没有父子关系，引用类型问题， 5 组合继承的优化-创建对象这种方式关键在于 借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以A对象为原型，生成了B对象。B继承了A的所有属性和方法 12345678910111213141516171819function Person (name, age) &#123; this.name = name, this.age = age&#125;Person.prototype.setAge = function () &#123; console.log(\"111\")&#125;function Student (name, age, price) &#123; //构造函数 Person.call(this, name, age) this.price = price this.setScore = function () &#123; &#125;&#125;Student.prototype = Object.create(Person.prototype)//核心代码Student.prototype.constructor = Student//核心代码var s1 = new Student('Tom', 20, 15000)console.log(s1 instanceof Student, s1 instanceof Person) // true trueconsole.log(s1.constructor) //Studentconsole.log(s1) 说明：Student.prototype = Object.create(Person.prototype) 创建一个基于Person的的prototype创建一个新的对象给Student，继承Person 的所有的属性和方法 （Object.create）Object身上挂载create这个方法可以创建新的对象 目前来说，使用缺点都解决了，但是还未趋近完美 6 Es6的class继承ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。 12345678910111213141516171819202122232425262728class Person &#123; //调用类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; //定义一般的方法 showName () &#123; console.log(\"调用父类的方法\") console.log(this.name, this.age); &#125;&#125;let p1 = new Person('kobe', 39)console.log(p1)//定义一个子类class Student extends Person &#123; constructor(name, age, salary) &#123; super(name, age)//通过super调用父类的构造方法 this.salary = salary &#125; showName () &#123;//在子类自身定义方法 console.log(\"调用子类的方法\") console.log(this.name, this.age, this.salary); &#125;&#125;let s1 = new Student('wade', 38, 1000000000)console.log(s1)s1.showName() 说明：本质上原型和class没有区别，但是代码的整洁可读性更高 ，super相当于原型继承的 Person.call(this, name, age)","categories":[{"name":"js高级","slug":"js高级","permalink":"http://wang-zhibiao.github.io/categories/js高级/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"js高级","slug":"js高级","permalink":"http://wang-zhibiao.github.io/categories/js高级/"}]},{"title":"vue组件传值","slug":"vue组件传值","date":"2019-06-15T04:10:56.000Z","updated":"2019-07-24T09:57:14.861Z","comments":true,"path":"2019/06/15/vue组件传值/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/15/vue组件传值/","excerpt":"","text":"1父传子通过父组件定义动态绑定一个数据来给子组件传递数据 ，子组件通过props来接受数据 1:data=\"data\" =&gt;&gt; props:&#123;data&#125; &gt;&gt;&gt;&gt;直接在template中使用data 具体例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;father&gt;&lt;/father&gt; &lt;/div&gt; &lt;template id='father'&gt; &lt;div class=\"father\"&gt; &lt;p&gt;我是父组件&#123;&#123;fname&#125;&#125;&lt;/p&gt; &lt;p&gt;我要告诉我儿子其实他是&#123;&#123;type&#125;&#125;&lt;/p&gt; &lt;son :mytype=\"type\"&gt;&lt;/son&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='son'&gt; &lt;div class=\"son\"&gt; &lt;p&gt;我是子组件&#123;&#123;sname&#125;&#125;&lt;/p&gt; &lt;p&gt;我的老爸告诉我我其实是&#123;&#123;mytype&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建父组件 Vue.component('father', &#123; template: '#father', data() &#123; return &#123; fname:'老爸', type:'穷二代' &#125; &#125;, // 通过components来创建子组件,可以创建多个 components: &#123; 'son': &#123; template: '#son', props:['mytype'], data() &#123; return &#123; sname:'小明', // mytype:'??' &#125; &#125; &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2子传父通过子组件发射（$emit）数据 父组件接受数据 1this.$emit(事件名称,你想传递的数据) =&gt;&gt;父组件监听这个事件（@/v-on） @事件名称=“方法（参数）” =&gt;&gt;这个方法默认参数就是传递的数据 具体例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;father&gt; &lt;/father&gt; &lt;/div&gt; &lt;template id='father'&gt; &lt;div class=\"father\" style='border:solid 1px'&gt; &lt;p&gt;我是父组件&#123;&#123;fname&#125;&#125;&lt;/p&gt; &lt;p&gt;我的儿子告诉我他的女朋友的名字叫&#123;&#123;erxifu&#125;&#125;&lt;/p&gt; &lt;!-- &lt;son v-on:getname='ok'&gt;&lt;/son&gt; --&gt; &lt;son @getname='ok'&gt;&lt;/son&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='son'&gt; &lt;div class=\"son\"&gt; &lt;p&gt;我是子组件&#123;&#123;sname&#125;&#125;&lt;/p&gt; &lt;button @click='tellname'&gt;点击告诉我老爸我的女朋友叫&#123;&#123;mygfname&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建父组件 Vue.component('father', &#123; template: '#father', data() &#123; return &#123; fname:'老爸', erxifu:'??' &#125; &#125;, methods:&#123; // 这个事件处理函数默认有一个参数,这个参数就是之前事件传递的数据 ok(data)&#123; console.log(data) this.erxifu = data &#125; &#125;, // 通过components来创建子组件,可以创建多个 components: &#123; 'son': &#123; template: '#son', data() &#123; return &#123; sname:'小明', mygfname:'小红' &#125; &#125;, methods:&#123; tellname()&#123; // 发射一个事件 // this.$emit(事件名称,你想传递的数据) // 数据可以是任意数据 this.$emit('getname',this.mygfname) &#125; &#125; &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, mounted()&#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html 3子传子通过事件总线传值，子组件通过事件总线对象发射数据，父组件接受数据 123var bus = new Vue() = \"创建vue事件总线\" =&gt;&gt; 子组件通过bus.$emit(事件名称,你想传递的数据) ==&gt;&gt;兄弟组件通过bus.$on(事件名称,(传递过来的数据)=&gt;&#123; 处理逻辑&#125;) 具体例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;father&gt; &lt;/father&gt; &lt;/div&gt; &lt;template id='father'&gt; &lt;div class=\"father\" style='border:solid 1px'&gt; &lt;p&gt;我是父组件&#123;&#123;fname&#125;&#125;&lt;/p&gt; &lt;son&gt;&lt;/son&gt; &lt;dauther&gt;&lt;/dauther&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='son'&gt; &lt;div class=\"son\"&gt; &lt;p&gt;我是儿子组件&#123;&#123;sname&#125;&#125;&lt;/p&gt; &lt;p&gt;我的妹妹回来了,跟我说她的男朋友叫:&#123;&#123;meifu&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id='dauther'&gt; &lt;div class=\"dauther\"&gt; &lt;p&gt;我是女儿组件&#123;&#123;dname&#125;&#125;&lt;/p&gt; &lt;button @click='tellname'&gt;点击向我哥哥炫耀我的男朋友的名字叫&#123;&#123;mybfname&#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建一个事件总线 var bus = new Vue() // 创建父组件 Vue.component('father', &#123; template: '#father', data() &#123; return &#123; fname: '老爸' &#125; &#125;, // 通过components来创建子组件,可以创建多个 components: &#123; 'son': &#123; template: '#son', data() &#123; return &#123; sname: '小明', meifu:'??' &#125; &#125;, // 在mounTed钩子函数中进行事件的监听 mounted()&#123; // 通过事件总线的$on进行事件的监听 // 事件处理函数默认有一个参数,就是传递的数据 bus.$on('getname',(data) =&gt; &#123; console.log(data) this.meifu = data &#125;) &#125; &#125;, 'dauther': &#123; template: '#dauther', data() &#123; return &#123; dname: '小红', mybfname:'狗蛋' &#125; &#125;, methods:&#123; // 通过事件总线发射一个事件 tellname()&#123; bus.$emit('getname',this.mybfname) &#125; &#125; &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, mounted() &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"vue基础","slug":"vue基础","permalink":"http://wang-zhibiao.github.io/categories/vue基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"}],"keywords":[{"name":"vue基础","slug":"vue基础","permalink":"http://wang-zhibiao.github.io/categories/vue基础/"}]},{"title":"来自平时的笔记","slug":"来自平时的笔记","date":"2019-06-11T16:00:00.000Z","updated":"2019-07-24T09:57:47.299Z","comments":true,"path":"2019/06/12/来自平时的笔记/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/12/来自平时的笔记/","excerpt":"","text":"隐藏元素：（1）visibility: hidden; 隐藏元素，占位置（2）display: none; 隐藏元素，不占位置（3）宽高设为0 显示元素： 与对应的隐藏属性用相同的属性，只不过值不同（1）visibility: visible 将隐藏的元素显示（2）display: block 将隐藏的元素显示，并能改变元素的显示方式 鼠标样式：cursor: pointer; /鼠标小手/ cursor: text; /文本光标/ cursor: move; /移动光标/ cursor: help; /鼠标小手/ 溢出文本处理overflow: hidden;overflow: visible;overflow: auto;overflow: scroll; 使用省略号替代溢出文本*必须让文本在一行显示，不能换行：white-space: nowrap;*溢出隐藏：overflow: hidden;*使用省略号替代文本：text-overflow: ellipsis; 设置文本间距：letter-spacing: 10px; 设置文字之间的间距word-spacing: 10px; 设置每个单词之间的间距 外轮廓线：outline(不占外边距位置)不影响盒子大小和距离outline: none;outline: 1px solid #fff; 防止文本域（textarea）拖拽改变大小：textarea { resize: none;} 垂直对齐方式：（只对行内元素和行内块级元素有效）verical-algin: middle; ***设置图片、input按钮与输入框等和文本的垂直对齐verical-algin: top; 设置顶线对齐 固定定位：*****注意:对于脱标的元素宽不会在和父元素一行宽，我们需要设置宽度或者有内容撑出来宽度 透明属性值：transparent Html5新增的标签：​ audio: 音频标签： ​ 属性值： controls控件，autoplay自动播放，loop循环播放可以设置循环次数 Html5中新增的标签属性：​ placeholder=””​ multiple​ required​ autofocus 自动聚焦，文本光标停留位置 Html5中新增的input属性的值：​ 搜索：type=”search” 移动端下面的键盘ENTER自动变成搜索​ 电话：type=”tel” 移动端下的键盘自动切换数字键盘​ 日期：type=”datetime”移动端显示日期滑动条 文字阴影属性：​ text-shadow:1px 2px 5px color； text-shadow:水平阴影，垂直阴影，阴影模糊度，阴影颜色​ 开发项目流程：​ 1.项目立项：产品的需求文档（产品经理）​ 2.产品原型图——UI针对其出设计稿​ ***我们这边会做项目结构搭建——开会：技术选型（确定项目中使用的主要技术点——项目的规范文档（例如：京东：jd_xxx）——项目任务分配——项目开发ing（多交流，多沟通）——测试（功能，代码）——上线——后期的维护，版本更新，迭代合资（外资企业）：​ 日资：​ 看着文档翻译​ 德资：​ 美资： 属性书写顺序：​ 1.布局定位属性：display / position / float / clear(建议display第一个写，毕竟关系到模式)​ 2.自身属性：​ 3.文本属性：​ 4.其他属性（CSS3）：content 引入外部样式顺序：兼容CSS——初始化CSS——公共CSS——当前页面CSS字体图标：一种字体类型（我们自己定义的）——主要针对于手机端 开发：让设计做一些这样的图标——前端开发将这样的图标通过工具生成一种字体——打包上传到服务器——下载现成字体图标网址：www.iconfont.cn 文本修饰：​ 水平位置设置： text-align： left center right 对于独占一行的元素，设置文本水平居中，将text-align属性设置给元素本身就行了​ 如果是一行可以显示多个的这样的元素，我们要设置文本水平居中，我们需要给这个元素的父元素设置text-align属性​ 垂直位置设置：行高 line-height: 300px; 当盒子高度等于行高的时候，盒子中的单行文本垂直居中​ 文本首行缩进： text-indent：​ 注意：em单位 相对长度单位。 相对的元素本身的字体大小​ 文本修饰线： text-decoration： none 去除默认的修饰线​ underline下划线 overline上划线 line-through中划线 修改定位元素的层级：​ 所有元素默认层级属性值是1​ z-index: 1;​ **1.层级只对非静态定位有效​ 2.如果都是非静态定位的元素，后面的元素的层级默认比前面的元素的层级高 做项目遵循单一性原则：​ 在项目中尽可能的让每一块的功能单一——为了程序的可拓展性和代码的复用； 在页面title处引入icon图标：icon图标:网页head里的title显示 截取网页的icon图标，在网页后面加上/favicon.ico 引入页面的title部分的icon图标： &lt;link rel=”shortcut icon” href=”./favicon.ico” 在线制作icon图标​ 网址：比特虫 www.bitbug.net 结构伪类选择器：​ ：nth-child（n）***n=odd基数 n=even偶数​ ：nth-child（-n+几） 前几个​ ：nth-last-child（-n+几）后几个 outline: 外边框线不占位置，商品hover时显示边框可用 p标签里面不能嵌套ul标签 怎么修改placeholder默认颜色？ input::placeholder{/\\ 去掉私有前缀，谷歌和火狐有效；IE和edge无效 */* color: orchid;opacity:1;font-size: 15px;} ****盒子模型分为几个部分：3个！！！！！！！外边距不算！！！ 1.旧的盒子模型——计算宽度 width = 边框 + 内边距 + 内容 2.新的盒子模型—— box-sizing:border-box;(内减模式) 改变边框和改变内边距都不会导致盒子的宽度发生改变 width = 边框 + 内边距 + 内容 内减模式——内容减少的模式 以后再写任何页面除非是ie8及以下， 都可以使用内减模式 * ***** { margin: 0; padding: 0; box-sizing: border-box; 快捷写法： bz } 3种改变元素坐标的技术有哪些：​ 1.定位——绝对定位——top left​ 2.外边距——margin​ 3.平移——translate*****区别：​ 1.margin和定位加的长度单位——px​ 2.margin和定位也可以用百分比单位——%​ 百分比相对于父元素的宽度计算​ 3.平移也可以用百分比单位——%​ 百分比相对于自身的宽度或者高度*****后期盒子中的盒子水平垂直居中显示可以用定位position的%和平移translate的%一起用来实现**布局的时候，属性的使用顺序：​ 1.大的布局，先用定位​ 2.微调的效果：（1）margin——挤压相邻的元素​ （2）平移——类似绝对定位，覆盖，不会挤压！不是脱标（导致父元素没有高度）。​ 3.平移的百分比单位——相对于自身的高度和宽度 容器开启3D效果： transform-style: preserve-3d; less:CSS预处理器注释： // 不会被编译到CSS /* 会被编译到CSS*/ ***换行和flex属性的有冲突，会重叠，如果想要前面的元素平分行，后面的元素换行显示，则可以用换行和width：百分比；来实现！！ 盒子透明度设置：opacity：.5；取值再0~1 合理设置版心宽度，使页面无论使用端的分辨率都不会出现横向滚动条 1.块级元素宽度默认100%； 2.当屏幕大于540px，块级元素的宽度最大就是540px； 3。当屏幕的宽小于540px时，块级元素的宽度=屏幕的宽度***max-width：540px； 在不同像素比的手机端显示不同倍清晰的图片： 1.市场上的手机全部都是高清晰度的手机2倍3倍 2.主流做法 美工只做一张高清的图片—2倍或者3倍 3.写代码的时候 直接使用这一张图片就OK，不用再去处理 不同屏幕不同的图片 弹性头部： flex:1，将父项除去其他定宽高的子顶剩余的宽度分成一等份，这一部分子项则可以随屏幕的变化来实现伸缩。 伪元素： 1.伪元素可以用来清除浮动：after 2.伪元素经常会被用来做字体图标或者小精灵图*****单标签不能加伪元素！！！ 设置a标签的样式可以继承父元素的样式： a{ color：inherit； } 颜色渐变：​ div{​ width: 200px;​ height: 200px;​ margin: 100px auto;​ border: 1px solid #000;​ /* ​ 1 渐变不是一种单纯的颜色 而是多种颜色​ 2 渐变要添加给标签的 background-image​ 3 线性渐变 radial 径向渐变 重复线性渐变 重复径向渐变​ / ​ / background-image: linear-gradient(to right,red,pink,yellow ,black,blue); / ​ / background-image: linear-gradient(0deg,red 20%,pink 50%,yellow ,black,blue); / ​ / background-image: radial-gradient(red,black); / ​ / background-image: repeating-linear-gradient() / ​ / css.chm 网上 都ok */​ } 两列的等高实现的方式：修改display属性值 1.父盒子 display：table-row； 2.子元素 display：table-cell；（cell单元格的意思） 清除浮动的写法2：​ display：table；​ content：“”； 相对长度单位： rem​ css3才有，相对于页面根标签html的字体大小 rem和px和em的区别 1.px绝对长度单位大小是固定 2.em是相对长度单位，相对于自身的字体大小 3.rem相对长度单位html标签的字体大小字体知识： 谷歌浏览器中默认字体大小是 16px； 谷歌浏览器中默认最小字体是 12px； 在普通的标签中字体大小会被继承——除h1~h6标签外 浮动：float​ float-left：给了元素此属性值，则若该元素的前面有向左浮动的元素则换行​ float-right：若该元素的前面的元素有向右浮动的元素则换行不关后面的元素事​ float-both***浮动BUG：1.给元素添加clear：both；清除浮动，强制换行；2.增加间距填补空间 内减模式：​ box-sizing: border-box;“给div 自己加宽度和高度，自己再增大padding的时候，不会增大盒子大小” js里面的事件派发： – js里面触发addEventListener注册的事件 – 使用的技术：事件派发 作用：让某个元素的事件被手动的触发 事件派发的三步:​ 1.先new一个事件对象 – 鼠标事件对象​ var 事件对象=new Event（事件的大类型） – 鼠标事件的大类型—MouseEvent​ var event=new Event(‘MouseEvents’)；​ 2.初始化事件对象​ 事件对象.initEvent（具体的事件类型，是否可以冒泡，是否可以阻止冒泡）​ event.initEvent(事件类型，是否冒泡，是否可以阻止)；​ 3.把事件对象派发除去​ 事件源.dispatchEvent（事件对象）；​ box.dispatchEvent（event）；​ ​","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"this指向，call，apply，bind","slug":"this指向，apply，call,bind","date":"2019-06-02T01:10:56.000Z","updated":"2019-08-31T13:19:12.391Z","comments":true,"path":"2019/06/02/this指向，apply，call,bind/","link":"","permalink":"http://wang-zhibiao.github.io/2019/06/02/this指向，apply，call,bind/","excerpt":"","text":"如何理解This指向 this ：谁调用它 他就指向谁。（this 永远指向最后调用它的那个对象） 1.在浏览器：如果this是在函数外部则this指向window 2.在node环境：如果this在函数外部则指向{} ​ 如果有new绑定 则指向这个new的实例对象 ​ 函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。 ​ 这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 undefined 或者 null，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window) 隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: xxx.fn() 箭头函数的情况：箭头函数没有自己的this，继承外层上下文绑定的this。 看看具体例子12345678var name = \"windowsName\";var a = &#123; // name: \"Cherry\", fn : function () &#123; console.log(this.name); //==》undefined &#125;&#125;window.a.fn(); 说明：这里有通过window调用a ，最后调用的是谁的呢？？ 其实是a最后调用了this=》》a里面没有那么这个属性，即使外面的window有name也不会调用==》》就像我们对于变量的调用一样，，函数内部的变量不可以使用其他的函数内部的变量，a和window是两个函数 即使window包括a但是调用的时候是使用this 指向了a 也就是标明 我一定要使用a里面的属性 再看看这个坑12345678910var name = \"windowsName\";var a = &#123; name : null, // name: \"Cherry\", fn : function () &#123; console.log(this.name); //==&gt; windowsName &#125;&#125;var f = a.fn;f(); 为什么和之前的调用差不多 this却是指向window 由上往下看，var f 的时候根本没有调用a.fn; 最后fn（） 是使用了window调用的 所以指向了外面的name this 的指向并不是在创建的时候就可以确定的 永远指向最后调用的它call和apply以及bind都与this有关 因为他们改变了this的指向先说说this改变的几种方法1.当你new一个对象时 this就指向创建的实例12let date = new Date()// 我们可以使用data创建时间 这是因为data的this在赋值当中已经指向实例new Date（） 12345new 的实现原理:创建一个空对象，构造函数中的this指向这个空对象这个新对象被执行 [[原型]] 连接执行构造函数方法，属性和方法被添加到this引用的对象中如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。 2.使用闭包解决，有两层函数可以再第一层使用_this= this改变指向123456789101112131415//在这里使用的是闭包的原理 也可以改变this的指向function()&#123; let _this = this function()&#123; console.log(_this) &#125;&#125;//可执行function fn() &#123; let _this = this return function () &#123; console.log(_this) &#125;() &#125; fn() 3.es6的箭头函数 指向外部的this，（）=&gt;{}箭头函数的 this 始终指向函数定义时的 this，而非执行时。 4.call apply bind call 123456789101112let Object = &#123; name: 'Mr.wang', first() &#123; console.log(this.name) &#125;, second() &#123; setTimeout(function () &#123; console.log(this.name); &#125;.call(Object)); &#125; &#125; Object.second() //==&gt; 输出为 Mr.wang apply 123456789101112let Object = &#123; name: 'Mr.wang', first() &#123; console.log(this.name) &#125;, second() &#123; setTimeout(function () &#123; console.log(this.name); &#125;.apply(Object)); &#125; &#125; Object.second() //==&gt; 输出为 Mr.wang bind 123456789101112let Object = &#123; name: 'Mr.wang', first() &#123; console.log(this.name) &#125;, second() &#123; setTimeout(function () &#123; console.log(this.name); &#125;.bind(Object)); &#125; &#125; Object.second() //==&gt; 输出为 Mr.wang apply 和 call 的区别他们之间的区别只是传入参数的区别 appll(this,[a,b,c])call(this,a,b,c)bind与apply和call有着大的区别 bind会生成新的函数，需要调用再次调用 setTimeout会自动调用","categories":[{"name":"Es6语法","slug":"Es6语法","permalink":"http://wang-zhibiao.github.io/categories/Es6语法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"Es6语法","slug":"Es6语法","permalink":"http://wang-zhibiao.github.io/categories/Es6语法/"}]},{"title":"Es6解构赋值","slug":"Es6变量的解构赋值","date":"2019-05-11T02:10:56.000Z","updated":"2019-07-14T01:28:26.270Z","comments":true,"path":"2019/05/11/Es6变量的解构赋值/","link":"","permalink":"http://wang-zhibiao.github.io/2019/05/11/Es6变量的解构赋值/","excerpt":"","text":"变量的解构赋值 数组的解构赋值 对象的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 函数参数的解构赋值 1数组的解构赋值12345let [a,b,c] = [1,2,3] // 为abc各自an规律赋值let [a,[b,[c]]] = [1,[2,[3]]] //如果为嵌套数组，可以用一样的嵌套数组赋值let [x,y] = [1,2,3] //如果赋值两边长度不一，，则部分赋值 部分未赋值为uddefinedlet [...arr] = [1,2,3] //扩展运算符可以直接把所有的数字赋值给arr arr=[1,2,3]let [first,...arrAll]=[1,2,3,4] //当第一个first赋值以后，其他的数字都会给arrAll包含 first =1 arrAll=[2,3,4] 结构赋值为何左右两边为数组？正常的赋值是一个一个赋值，解构赋值是吧需要赋值的解析重构，循环赋值 通过数组可遍历的特性就可以解构 解构赋值的默认值123let [a=11] = [] //a输出为11 在赋值之前就已经赋值 解构只是再次赋值 不会冲突 注意点 [] 数组里面无任何值，但是有undefined 所以才会解构成功 ，否则部分赋值也不会实现，以下情况请注意 null与undefined有本质的区别，两者不等，所以赋值时可以成功为null，解构赋值也严格遵守严格运算符（===）let [x = 1] = [undefined];//x = 1let [x = 1] = [null]; //x = null 2对象的解构赋值12345678910let &#123;a&#125;=&#123;a:'good',b:'nice'&#125; //a = good 对象里不同于数组，它是无序的集合 所以赋值要用见来赋值 两者的键要相同//如果没有对应的键则会返回undefined//对象的解构赋值可以对内置对象进行赋值let&#123;log,sin,cos&#125; = Mathlet &#123;log&#125; = console//当取得所对应的对象的方法时，可以直接调用log('hello word') //控制台输出hello wordsin(90) //输出为 1let &#123;a，&#123;b&#125;&#125; = &#123;a:11,&#123;b:22&#125;&#125; //对象一样支持嵌套赋值var &#123;x = 3&#125; = &#123;&#125;; //也支持默认值 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 注意点12345678let x;&#123;x&#125; = &#123;x: 1&#125;; //已经声明的变量再解构赋值会报错 ，&#123;x&#125; 会被解析为代码块//解决方法(&#123;x&#125;=&#123;x:1&#125;); //括号包裹//解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。(&#123;&#125;=&#123;a:dd&#125;) //语法可行但毫无意义//数组也是一种特殊的对象 他是用索引值当键let &#123;0:first&#125; = [1,2,3] 3字符串的解构赋值12let [a,b,c,d,e] = 'hello' // a=h,b=e,c=l,d=l,e=o //这是将字符串转化为数组遍历在赋值let &#123;length : len&#125; = 'hello'; //len = 5 // 数组都有length这个键 表示长度 4数值和布尔值的解构赋值12345678let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true//数字和布尔类型会转化为对象 所以在s的原型链与赋值的原型链相等 前面的键 toString 是转化为字符串的方法let &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true// 由于ndefined和null无法转为对象 所以不能进行赋值let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 5函数参数的解构赋值函数的解构赋值我们经常使用 当我们进行传参时 就会进行解构赋值 1234function fn(a,b)&#123; return a+b&#125;fn(2,3) //a和b都会在函数调用时传参解构赋值 函数参数的默认值 12345678function fn(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8] fn(&#123;x: 3&#125;); // [3, 0]fn(&#123;&#125;); // [0, 0]fn(); // [0, 0]//如果有默认值,参数没有就使用默认值 另一种函数的默认值 123456789function fn(&#123;x, y&#125; = &#123;x:0,y:0&#125;) &#123; return [x, y];&#125;fn(&#123;x: 3, y: 8&#125;); // [3, 8] fn(&#123;x: 3&#125;); // [3, undefined]fn(&#123;&#125;); // [undefined, undefined]fn(); // [0, 0]//如果有默认值,参数没有就使用默认值//这种写法使用了对象的键值对赋值，不是之前的值传递，所以 当参数为&#123;&#125;时 传递的是undefined 圆括号圆括号是为了解决赋值时解析的无法辨别，但是要注意使用时机，否则会报错","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"Es6","slug":"Es6","permalink":"http://wang-zhibiao.github.io/tags/Es6/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"let var const三种定义方式及闭包","slug":"var let const三种定义方式及闭包","date":"2019-05-09T16:10:56.000Z","updated":"2019-07-14T01:27:55.718Z","comments":true,"path":"2019/05/10/var let const三种定义方式及闭包/","link":"","permalink":"http://wang-zhibiao.github.io/2019/05/10/var let const三种定义方式及闭包/","excerpt":"","text":"let var const 之间的区别varvar的作用域是根据函数作用域的， 他在函数内起作用 这里就引用到闭包和作用域链 12345678function out()&#123; var a = 000; //=&gt; 这个a的作用域作用在out内 而info函数在out函数内 所以可以调用 b=222 //=&gt; 报错err 因为b的作用域在info函数内 包裹他的out函数不可以调用它function info()&#123; var b=999; a= 111; &#125;&#125; var 的变量提升 12345678function ()&#123; var a=10; &#125;//变量提升 就是var定义的变量会在先声明再赋值 提升到函数顶部function()&#123; var a; a=10;&#125; letlet的作用域的块级作用域，不会变量提升 可以理解为在某块范围内作用 与var 的函数作用域不同在于 let的作用域会形成闭包 12345678910111213for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 3 3 3for (let i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125;//输出 0 1 2 12var会在全局声明 而setTimeout 是一个定时器 也是异步回调 会在同步执行完毕再执行异步 所以当for循环完毕 i=3时调用三次定时器 let 的作用范围会在for循环内 每循环一次 i会形成一次闭包 i会被setTimeout调用 constconst代表一个值的常量索引，常量的值在垃圾回收前永远不能改变，所以需要谨慎使用。 cosnt定义的值不能被改变 否则会报错 12Uncaught TypeError: Assignment to constant variable.未捕获的类型错误:赋值给常量变量。 闭包外部可以访问内部的私有变量 可以返回携带状态的函数，并且状态隐藏 可以做到变量的私有 123456function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125;return f2;&#125;var result=f1();result(); // 999 闭包就是能够读取其他函数内部变量的函数 要形成闭包 必须两层function函数作用域 123456789101112function f1()&#123; var n=999; Add=function()&#123;n+=1&#125; function f2()&#123; console.log(n)&#125;return f2;&#125;var result=f1();result(); // 999Add();result(); // 1000 这里形成闭包后，f1的局部变量n一直保存在内存中，并没有因为f1的重复调用而清除 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 缺点由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 12345678910var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); 经典闭包题 个人理解 object.getNameFunc() 执行到这一步时 调用object内的函数 返回一个function（）{return this.name} 这时候 name还是My Object 当再次执行时object.getNameFunc()() 调用了外部的name 输出为The Window","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"隐藏元素的方法","slug":"隐藏元素的方法","date":"2019-03-21T16:10:56.000Z","updated":"2019-07-13T02:29:27.392Z","comments":true,"path":"2019/03/22/隐藏元素的方法/","link":"","permalink":"http://wang-zhibiao.github.io/2019/03/22/隐藏元素的方法/","excerpt":"","text":"隐藏类型 屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类： 完全隐藏：元素从DOM树中消失，不占据空间。 视觉上的隐藏：屏幕中不可见，占据空间。 语义上的隐藏：读屏软件不可读，但正常占据空间。 完全隐藏 1.display 属性1display: none; 2.hidden 属性 HTML5 新增属性，相当于 display: none 12&lt;div hidden&gt;&lt;/div&gt; 视觉上的隐藏,在页面中还存在 3.利用 position 和 盒模型 将元素移出可视区范围 设置 posoition 为 absolute 或 fixed，\b通过设置 top、left 等值，将其移出可视区域。 12position:absolute;left: -999px; 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。 12position: relative;left: -999px; 设置 margin 值，将其移出可视区域范围（可视区域占位）。 12margin-left: -99999px;height: 0; 3.利用 transfrom 缩放 12transform: scale(0);height: 0; 移动 translateX, translateY 12transform: translateX(-99999px);height: 0 旋转 rotate 1transform: rotateY(90deg) //直角在界面上形成线性视觉屏蔽 4.设置其大小为0 宽高为0，字体大小为0： 123height: 0;width: 0;font-size: 0; 宽高为0，超出隐藏: 123height: 0;width: 0;overflow: hidden; 5.设置透明度为01opacity: 0; 6.visibility属性1visibility: hidden; 7.层级覆盖，z-index 属性12position: relative;z-index: -999; 再设置一个层级较高的元素覆盖在此元素上。8.clip-path 裁剪1clip-path: polygon(0 0, 0 0, 0 0, 0 0); 语义上的隐藏","categories":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"基础","slug":"基础","permalink":"http://wang-zhibiao.github.io/categories/基础/"}]},{"title":"简单轮播图原理解析","slug":"简单轮播图原理解析","date":"2019-03-11T16:10:56.000Z","updated":"2019-07-28T01:12:20.044Z","comments":true,"path":"2019/03/12/简单轮播图原理解析/","link":"","permalink":"http://wang-zhibiao.github.io/2019/03/12/简单轮播图原理解析/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/** * 动画函数 animate 版本1 * @param element 动画元素 * @param target 动画目标值 * @param step 动画步长(可选参数) */function animate(element, target, step) &#123; step = step || 10; var current = element.offsetLeft; clearInterval(element.timer); element.timer = setInterval(function () &#123; current += current &lt; target ? step : -step; element.style.left = current + 'px'; if (Math.abs(target - current) &lt;= step) &#123; clearInterval(element.timer); element.style.left = target + 'px'; &#125; &#125;, 24);&#125;/** * 动画函数 animate 版本2 * @param element 动画元素 * @param target 动画目标值 */function animate_v2(element, target) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; var current = element.offsetLeft; var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style.left = current + 'px'; if (target === current) &#123; clearInterval(element.timer); &#125; &#125;, 240);&#125;/** * 动画函数 animate 版本3 宽度动画 * @param element 动画元素 * @param target 动画目标值 */function animate_v3(element, target) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; /* 改变 v3.1 →: 获取盒子宽度 */ var current = element.offsetWidth; var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* 改变 v3.2 →: 设置宽度样式 */ element.style.width = current + 'px'; if (target === current) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/** * 动画函数 animate_v4 任意单位为px的属性能发生变化 * @param element 动画元素 * @param attr 动画属性 * @param target 动画目标 *//* 改变 v4.1 →: 多了一个 attr 参数代表属性 */function animate_v4(element, attr, target) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; /* 改变 v4.2 →: 根据传进来的属性获取当前样式值 */ var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* 改变 v4.3 →: 根据属性设置样式 */ element.style[attr] = current + 'px'; if (target === current) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/* 改变 v5.1 →: 参数变成样式对象 styleObj */function animate_v5(element, styleObj) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; /* 1. 立 flag，假设要清除 */ var flag = true; /* 改变 v5.2 →: 遍历样式对象 */ for (var attr in styleObj) &#123; /* 改变 v5.3 →: 根据属性名，获取目标值 */ var target = styleObj[attr]; var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style[attr] = current + 'px'; /* 2. 改 flag，假设不成立，修改成 假 */ if (target !== current) &#123; flag = false; &#125; &#125; /* 3. 用 flag，循环结束后判断 flag 的值是真还是假 */ if (flag) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/** * v8 层级不做动画，透明度，px 有动画效果 * @param element * @param styleObj */function animate_v8(element, styleObj) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; var flag = true; for (var attr in styleObj) &#123; if (attr === 'zIndex') &#123; var target = styleObj[attr]; element.style[attr] = target; &#125; else if (attr === 'opacity') &#123; /* v6.1 在数据的源头，把&lt;目标值&gt;和&lt;当前值&gt;乘 100 处理成&lt;整数&gt; */ var target = 100 * styleObj[attr]; var current = 100 * parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; /* 取整为什么会出问题？数据的源头是小数，直接处理数据源头 */ step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* v6.2 单位设置，不要 px 单位，除 100 变回小数 */ element.style[attr] = current / 100; if (target !== current) &#123; flag = false; &#125; &#125; else &#123; /* 改变 v5.3 →: 根据属性名，获取目标值 */ var target = styleObj[attr]; var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style[attr] = current + 'px'; /* 2. 改 flag，假设不成立，修改成 假 */ if (target !== current) &#123; flag = false; &#125; &#125; &#125; /* 3. 用 flag，循环结束后判断 flag 的值是真还是假 */ if (flag) &#123; clearInterval(element.timer); &#125; &#125;, 24);&#125;/* vX.1 开放新的参数：动画回调函数 fn */function animate_vX(element, styleObj, fn) &#123; clearInterval(element.timer); element.timer = setInterval(function () &#123; var flag = true; for (var attr in styleObj) &#123; if (attr === 'zIndex') &#123; var target = styleObj[attr]; element.style[attr] = target; &#125; else if (attr === 'opacity') &#123; /* v6.1 在数据的源头，把&lt;目标值&gt;和&lt;当前值&gt;乘 100 处理成&lt;整数&gt; */ var target = 100 * styleObj[attr]; var current = 100 * parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; /* 取整为什么会出问题？数据的源头是小数，直接处理数据源头 */ step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; /* v6.2 单位设置，不要 px 单位，除 100 变回小数 */ element.style[attr] = current / 100; if (target !== current) &#123; flag = false; &#125; &#125; else &#123; /* 改变 v5.3 →: 根据属性名，获取目标值 */ var target = styleObj[attr]; var current = parseFloat(getComputedStyle(element)[attr]); var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; element.style[attr] = current + 'px'; /* 2. 改 flag，假设不成立，修改成 假 */ if (target !== current) &#123; flag = false; &#125; &#125; &#125; /* 3. 用 flag，循环结束后判断 flag 的值是真还是假 */ if (flag) &#123; clearInterval(element.timer); /* vX.2 动画结束后，调用函数 */ // if (fn) &#123; // fn(); // &#125; /** * || 找真，如果前面假，后面就是真，执行后面代码 * &amp;&amp; 找假，如果前面真，后面就是假，执行后面代码 **/ fn &amp;&amp; fn(); &#125; &#125;, 24);&#125;","categories":[{"name":"js封装","slug":"js封装","permalink":"http://wang-zhibiao.github.io/categories/js封装/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"analysis","slug":"analysis","permalink":"http://wang-zhibiao.github.io/tags/analysis/"}],"keywords":[{"name":"js封装","slug":"js封装","permalink":"http://wang-zhibiao.github.io/categories/js封装/"}]},{"title":"BFC协议","slug":"BFC协议","date":"2018-12-29T16:14:56.000Z","updated":"2019-07-14T01:29:51.152Z","comments":true,"path":"2018/12/30/BFC协议/","link":"","permalink":"http://wang-zhibiao.github.io/2018/12/30/BFC协议/","excerpt":"","text":"什么是BFC？BFC的布局规则是什么？如何创建BFC？查看解析 Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。 元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。 Formatting Context Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。 Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。 BFC布局规则 BFC内，盒子依次垂直排列。 BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】 BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 如何创建BFC 根元素 浮动元素（float 属性不为 none） position 为 absolute 或 fixed overflow 不为 visible 的块元素 display 为 inline-block, table-cell, table-caption BFC 的应用 防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠) 清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算) 自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://wang-zhibiao.github.io/tags/function/"}],"keywords":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/categories/javascript/"}]},{"title":"盒子居中的方法","slug":"盒子居中的方法","date":"2018-12-20T11:50:59.000Z","updated":"2019-07-14T01:29:23.856Z","comments":true,"path":"2018/12/20/盒子居中的方法/","link":"","permalink":"http://wang-zhibiao.github.io/2018/12/20/盒子居中的方法/","excerpt":"","text":"HTML盒子居中的方法：1.宽度和高度已知的。思路： 父元素相对定位 子元素绝对定位 子元素{ left: 50%;top: 50%;margin-left: 减去子元素的宽度一半。margin-top: 减去子元素的高度一半； } 1234567891011121314151617&lt;style type=\"text/css\"&gt; #box&#123; width: 400px; height: 200px; position: relative; background: red; //方便观看 &#125; #box1&#123; width: 200px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -100px; //定位后偏移值超过子元素的宽度一半需减去 margin-top: -50px; //定位后偏移值超过子元素的高度一半需减去 background: green; &#125; 2.宽度和高度可以随意改变思路： 父元素相对定位 子元素绝对定位 子元素{ left: 0;top: 0; bottom:0;right:0; margin:auto; } 1234567891011121314151617#box&#123; width: 800px; height: 400px; position: relative; background: red; &#125;#box1&#123; width: 100px; height: 50px; position: absolute;//四个方位定义盒子所在的位置 当所有为0&amp;&amp;margin:auto时,盒子居中 top: 0; right: 0; bottom: 0; left: 0; margin: auto; background: green; &#125; 3.flex布局123456789101112131415.box&#123; width: 400px; height: 200px; background: #f99; &#125; .box1&#123; width: 200px; height: 100px; background: green; &#125; .center&#123; display: flex; //开启弹性盒子 主轴侧轴交叉得到居中 justify-content: center;//实现水平居中 align-items: center;//实现垂直居中 &#125; 4.平移 定位+transform123456789101112131415.parent_box&#123; width: 400px; height: 200px; background: red; position: relative; &#125; .child_box&#123; width: 200px; height: 100px; background: green; position: absolute;//与第一个类似 但可以根据子元素的宽高自动居中 top: 50%; left: 50%; transform: translate( -50%,-50%);//平移相当于盒子margin(左,上)减半 &#125; 如何清除浮动清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。 使用after伪元素清除浮动12345678.clearfix:after &#123; content: \"\"; display: block; height: 0; clear: both; visibility: hidden;&#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 */ 使用before和after双伪元素清除浮动12345678910.clearfix:before,.clearfix:after &#123; content:\"\"; display:table; /* 这句话可以触发BFC BFC可以清除浮动 */&#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 浏览器查询Unicode编码 浏览器控制台输出 escape(‘查询字符串’)","categories":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}],"tags":[{"name":"css","slug":"css","permalink":"http://wang-zhibiao.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"http://wang-zhibiao.github.io/tags/html/"},{"name":"debug","slug":"debug","permalink":"http://wang-zhibiao.github.io/tags/debug/"}],"keywords":[{"name":"知识","slug":"知识","permalink":"http://wang-zhibiao.github.io/categories/知识/"}]},{"title":"好好喝水","slug":"喝水记","date":"2018-08-08T00:08:08.000Z","updated":"2020-01-03T13:58:55.811Z","comments":true,"path":"2018/08/08/喝水记/","link":"","permalink":"http://wang-zhibiao.github.io/2018/08/08/喝水记/","excerpt":"","text":"每天喝水最佳时间 6:30:经过一整夜的睡眠,身体开始缺水,起床之际先喝250毫升的水,可帮助肾脏及肝脏排毒。 8:30:清晨从起床到办公室的过程,时间总是特别紧凑,情绪也较紧张,身体无形中会出现脱水现象,所以到了办公室后,先别急着泡咖啡,给自己一杯至少250毫升的水。 11:00:工作一段时间后,一定得趁起身动动的时候,再给自己一天里的第三杯水,补充流失的水分,有助于放松紧张的工作情绪。 12:50:用完午餐半小时后,喝一些水,可以加强身体的消化功能。 15:00:以一杯健康矿泉水代替午茶与咖啡等提神饮料吧,能够提神醒脑。 17:30:下班离开办公室前,再喝一杯水,增加饱足感,待会吃晚餐时,自然不会暴饮暴食。 22:00:睡前1至半小时再喝上一杯水。今天已摄取2000毫升水量了。不过别一口气喝太多,以免晚上上洗手间影响睡眠质量。","categories":[{"name":"water","slug":"water","permalink":"http://wang-zhibiao.github.io/categories/water/"}],"tags":[{"name":"water","slug":"water","permalink":"http://wang-zhibiao.github.io/tags/water/"}],"keywords":[{"name":"water","slug":"water","permalink":"http://wang-zhibiao.github.io/categories/water/"}]},{"title":"简历","slug":"个人简历","date":"2017-12-31T16:10:56.000Z","updated":"2019-08-22T08:44:56.381Z","comments":true,"path":"2018/01/01/个人简历/","link":"","permalink":"http://wang-zhibiao.github.io/2018/01/01/个人简历/","excerpt":"","text":"个人信息 ​ 性别：男 年龄：23 手机：132-4275-8485 ​ 邮箱：wangxx599@163.com 个人博客地址 https://wang-zhibiao.github.io/ 基本技能 掌握HTML/CSS/Javascript 等前端技术，熟悉HTML5/CSS3技术，能快速写出符合 W3C 标准、兼容主流浏览器的代码，对表现与数据分离、Web语义化等有深刻理解； ； 熟练掌握javascript语言，熟练运用jQuery库、bootstrap能够实现网页的动态效果与页面交互； 熟悉原生js闭包，作用域，原型链，js面向对象等基础知识； 熟练运用Vue，vue-cli、webpack打包工具来制作pc端的单页面应用； 熟练运用自定义组件、路由等微信小程序相关技术，来制作微信小程序相关应用； 熟练掌握Ajax+Promise技术及使用Navicat对数据库进行简单操作； 熟练掌握less、scss预处理器、ECharts、git、swiper、qrcode、等有关功能插件的运用； 使用Git版本管理工具，能够用Git和Github进行配合管理项目版本；","categories":[{"name":"简历","slug":"简历","permalink":"http://wang-zhibiao.github.io/categories/简历/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wang-zhibiao.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://wang-zhibiao.github.io/tags/vue/"}],"keywords":[{"name":"简历","slug":"简历","permalink":"http://wang-zhibiao.github.io/categories/简历/"}]}]}